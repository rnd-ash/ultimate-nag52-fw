
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'EZS51'
*/

#ifndef __ECU_EZS51_H_
#define __ECU_EZS51_H_

#include <stdint.h>
    
#define EZS_240_EGS51_CAN_ID 0x0240
#define KLA_410_EGS51_CAN_ID 0x0410

/** LHD / RHD */
enum class EZS_240h_LL_RLC_EGS51 : uint16_t {
	UNKNOWN = 0, // not defined
	LL = 1, // Left
	RL = 2, // RHD
	SNV = 3, // Code not available
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint64_t __PADDING1__: 40;
		/** Message counter **/
		uint8_t BZ240h: 4;
		/** cruise control lever parity (even parity) **/
		bool WH_PA: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING2__: 3;
		/** Terminal 50 **/
		bool KL_50: 1;
		/** Terminal 15 **/
		bool KL_15: 1;
		/** brake switch for Shift Lock **/
		bool BS_SL: 1;
		/** Reverse gear engaged (manual transmission only) **/
		bool RG_SCHALT: 1;
		/** LHD / RHD **/
		EZS_240h_LL_RLC_EGS51 LL_RLC: 2;
		/** meets Keyles Go annealing conditions **/
		bool KG_ALB_OK: 1;
		/** Keyless Go terminal control active **/
		bool KG_KL_AKT: 1;
		/** cruise control lever "off" **/
		bool AUS: 1;
		/** cruise control lever: "resume" **/
		bool WA: 1;
		/** cruise control lever: "Sit and accelerating Stufe0" **/
		bool S_PLUS_B: 1;
		/** cruise control lever: "Sit and delay Stufe0" **/
		bool S_MINUS_B: 1;
		/** Operation variable speed limit **/
		bool VMAX_AKT: 1;
		/** cruise control lever implausible **/
		bool WH_UP: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING3__: 2;
	} __attribute__((packed));
	/** Gets CAN ID of EZS_240_EGS51 **/
	uint32_t get_canid(){ return EZS_240_EGS51_CAN_ID; }
} EZS_240_EGS51;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint32_t __PADDING1__: 32;
		/** Motor fan setpoint speed **/
		uint8_t NLFTS: 8;
		/** Torque recording refrigeration compressor **/
		uint8_t M_KOMP: 8;
		/** refrigerant printing **/
		uint8_t P_KAELTE8: 8;
		/** climate compressor turned on **/
		bool KOMP_EIN: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING2__: 5;
		/** idle speed lifting to the cooling power increase **/
		bool LL_DZA: 1;
		/** Climate Compressor Tour NEW **/
		uint8_t M_KOMP_NEU: 8;
		/** Climate Compressor Tour Toggle **/
		bool M_KOMPTGL: 1;
		/** Climate Compressor Torque Parity (straight parity) **/
		bool M_KOMPPAR: 1;
		/** signal version Compressor torque **/
		bool SENDE_NEU: 1;
		/** Turn on a heater **/
		bool ZH_EIN_OK: 1;
	} __attribute__((packed));
	/** Gets CAN ID of KLA_410_EGS51 **/
	uint32_t get_canid(){ return KLA_410_EGS51_CAN_ID; }
} KLA_410_EGS51;



class ECU_EZS51 {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint32_t timestamp_now) {
            uint8_t idx = 0;
            bool add = true;
            switch(can_id) {
                case EZS_240_EGS51_CAN_ID:
                    idx = 0;
                    break;
                case KLA_410_EGS51_CAN_ID:
                    idx = 1;
                    break;
                default:
                    add = false;
                    break;
            }
            if (add) {
                LAST_FRAME_TIMES[idx] = timestamp_now;
                FRAME_DATA[idx] = value;
            }
            return add;
        }
        
        /** Sets data in pointer to EZS_240
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_EZS_240(const uint32_t now, const uint32_t max_expire_time, EZS_240_EGS51* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[0] <= now && now - LAST_FRAME_TIMES[0] < max_expire_time) {
                dest->raw = FRAME_DATA[0];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to KLA_410
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_KLA_410(const uint32_t now, const uint32_t max_expire_time, KLA_410_EGS51* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[1] <= now && now - LAST_FRAME_TIMES[1] < max_expire_time) {
                dest->raw = FRAME_DATA[1];
                ret = true;
            }
            return ret;
        }
            
	private:
		uint64_t FRAME_DATA[2];
		uint32_t LAST_FRAME_TIMES[2];
};
#endif // __ECU_EZS51_H_