
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'EZS51'
*/

#ifndef __ECU_EZS51_H_
#define __ECU_EZS51_H_

#include <stdint.h>
    
#define EZS_240EGS51_CAN_ID 0x0240
#define KLA_410EGS51_CAN_ID 0x0410

/** LHD / RHD */
enum class EZS_240h_LL_RLCEGS51 {
	UNKNOWN = 0, // not defined
	LL = 1, // Left
	RL = 2, // RHD
	SNV = 3, // Code not available
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of EZS_240EGS51 */
	uint32_t get_canid(){ return EZS_240EGS51_CAN_ID; }
    /** Sets cruise control lever implausible */
    void set_WH_UP(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets cruise control lever implausible */
    bool get_WH_UP() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Operation variable speed limit */
    void set_VMAX_AKT(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Operation variable speed limit */
    bool get_VMAX_AKT() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets cruise control lever: "Sit and delay Stufe0" */
    void set_S_MINUS_B(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets cruise control lever: "Sit and delay Stufe0" */
    bool get_S_MINUS_B() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets cruise control lever: "Sit and accelerating Stufe0" */
    void set_S_PLUS_B(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets cruise control lever: "Sit and accelerating Stufe0" */
    bool get_S_PLUS_B() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets cruise control lever: "resume" */
    void set_WA(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets cruise control lever: "resume" */
    bool get_WA() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets cruise control lever "off" */
    void set_AUS(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets cruise control lever "off" */
    bool get_AUS() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets Keyless Go terminal control active */
    void set_KG_KL_AKT(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets Keyless Go terminal control active */
    bool get_KG_KL_AKT() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets meets Keyles Go annealing conditions */
    void set_KG_ALB_OK(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets meets Keyles Go annealing conditions */
    bool get_KG_ALB_OK() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets LHD / RHD */
    void set_LL_RLC(EZS_240h_LL_RLCEGS51 value){ raw = (raw & 0xffcfffffffffffff) | ((uint64_t)value & 0x3) << 52; }

    /** Gets LHD / RHD */
    EZS_240h_LL_RLCEGS51 get_LL_RLC() const { return (EZS_240h_LL_RLCEGS51)(raw >> 52 & 0x3); }
        
    /** Sets Reverse gear engaged (manual transmission only) */
    void set_RG_SCHALT(bool value){ raw = (raw & 0xfff7ffffffffffff) | ((uint64_t)value & 0x1) << 51; }

    /** Gets Reverse gear engaged (manual transmission only) */
    bool get_RG_SCHALT() const { return (bool)(raw >> 51 & 0x1); }
        
    /** Sets brake switch for Shift Lock */
    void set_BS_SL(bool value){ raw = (raw & 0xfffbffffffffffff) | ((uint64_t)value & 0x1) << 50; }

    /** Gets brake switch for Shift Lock */
    bool get_BS_SL() const { return (bool)(raw >> 50 & 0x1); }
        
    /** Sets Terminal 15 */
    void set_KL_15(bool value){ raw = (raw & 0xfffdffffffffffff) | ((uint64_t)value & 0x1) << 49; }

    /** Gets Terminal 15 */
    bool get_KL_15() const { return (bool)(raw >> 49 & 0x1); }
        
    /** Sets Terminal 50 */
    void set_KL_50(bool value){ raw = (raw & 0xfffeffffffffffff) | ((uint64_t)value & 0x1) << 48; }

    /** Gets Terminal 50 */
    bool get_KL_50() const { return (bool)(raw >> 48 & 0x1); }
        
    /** Sets cruise control lever parity (even parity) */
    void set_WH_PA(bool value){ raw = (raw & 0xffffefffffffffff) | ((uint64_t)value & 0x1) << 44; }

    /** Gets cruise control lever parity (even parity) */
    bool get_WH_PA() const { return (bool)(raw >> 44 & 0x1); }
        
    /** Sets Message counter. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_BZ240h(uint8_t value){ raw = (raw & 0xfffff0ffffffffff) | ((uint64_t)value & 0xf) << 40; }

    /** Gets Message counter. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_BZ240h() const { return (uint8_t)(raw >> 40 & 0xf); }
        
} EZS_240EGS51;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of KLA_410EGS51 */
	uint32_t get_canid(){ return KLA_410EGS51_CAN_ID; }
    /** Sets Turn on a heater */
    void set_ZH_EIN_OK(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Turn on a heater */
    bool get_ZH_EIN_OK() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets signal version Compressor torque */
    void set_SENDE_NEU(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets signal version Compressor torque */
    bool get_SENDE_NEU() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Climate Compressor Torque Parity (straight parity) */
    void set_M_KOMPPAR(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Climate Compressor Torque Parity (straight parity) */
    bool get_M_KOMPPAR() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Climate Compressor Tour Toggle */
    void set_M_KOMPTGL(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Climate Compressor Tour Toggle */
    bool get_M_KOMPTGL() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Climate Compressor Tour NEW. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_M_KOMP_NEU(uint8_t value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets Climate Compressor Tour NEW. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_M_KOMP_NEU() const { return (uint8_t)(raw >> 40 & 0xff); }
        
    /** Sets idle speed lifting to the cooling power increase */
    void set_LL_DZA(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets idle speed lifting to the cooling power increase */
    bool get_LL_DZA() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets climate compressor turned on */
    void set_KOMP_EIN(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets climate compressor turned on */
    bool get_KOMP_EIN() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets refrigerant printing. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_P_KAELTE8(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets refrigerant printing. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_P_KAELTE8() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Torque recording refrigeration compressor. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_M_KOMP(uint8_t value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets Torque recording refrigeration compressor. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_M_KOMP() const { return (uint8_t)(raw >> 40 & 0xff); }
        
    /** Sets Motor fan setpoint speed. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_NLFTS(uint8_t value){ raw = (raw & 0xffffff00ffffffff) | ((uint64_t)value & 0xff) << 32; }

    /** Gets Motor fan setpoint speed. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_NLFTS() const { return (uint8_t)(raw >> 32 & 0xff); }
        
} KLA_410EGS51;



class ECU_EZS51 {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case EZS_240EGS51_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case KLA_410EGS51_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to EZS_240
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_EZS_240(uint64_t now, uint64_t max_expire_time, EZS_240EGS51* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[0] && now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
        /** Sets data in pointer to KLA_410
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_KLA_410(uint64_t now, uint64_t max_expire_time, KLA_410EGS51* dest) const {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[1] && now - LAST_FRAME_TIMES[1] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[1];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[2];
		uint64_t LAST_FRAME_TIMES[2];
};
#endif // __ECU_EZS51_H_