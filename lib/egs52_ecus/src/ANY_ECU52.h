
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'ANY_ECU'
*/

#ifndef __ECU_ANY_ECU_H_
#define __ECU_ANY_ECU_H_

#include <stdint.h>
    
#define ARCADE_A2_CAN_ID 0x0035
#define MS_ANZ_CAN_ID 0x033D
#define SBW_232_CAN_ID 0x0232
#define ART_250_CAN_ID 0x0250
#define ART_258_CAN_ID 0x0258
#define PSM_3B4_CAN_ID 0x03B4
#define PSM_3B8_CAN_ID 0x03B8
#define VG_428_CAN_ID 0x0428
#define LWR_530_CAN_ID 0x0530
#define CONFIG_6FF_CAN_ID 0x06FF

/** Number of ASA alert */
enum class MS_ANZ_ASS_WARN {
	IDLE = 0, // No status / warning
	M1 = 1, // Message "ASA inactive: warming up the engine"
	M2 = 2, // Message "ASA Active driving"
	M3 = 3, // Message "ASA Active stop mode"
	M4 = 4, // Message "ASA switched off: electrical power supplies"
	M5 = 5, // Message "ASA switched off: air conditioner"
	M6 = 6, // Message "ASA not active: Fault"
	M7 = 7, // Message "ASA Active electrical energy demand, Please start engine"
	M8 = 8, // Message "ASA active: For starting clutch kick"
	M9 = 9, // Message "ASA active: Air start Please Motor"
	M10 = 10, // Message "ASA Active: When leaving ignition off!"
	M11 = 11, // Message "ASA disabled"
	M12 = 12, // Message "ASA activated"
	M13 = 13, // Message "ASA: Display defective"
	M14 = 14, // not defined
	M15 = 15, // not defined
};

/** Number of ASA status message */
enum class MS_ANZ_ASS_DSPL {
	IDLE = 0, // No status / warning
	M1 = 1, // Message "ASA inactive: warming up the engine"
	M2 = 2, // Message "ASA Active driving"
	M3 = 3, // Message "ASA Active stop mode"
	M4 = 4, // Message "ASA switched off: electrical power supplies"
	M5 = 5, // Message "ASA switched off: air conditioner"
	M6 = 6, // Message "ASA not active: Fault"
	M7 = 7, // Message "ASA Active electrical energy demand, Please start engine"
	M8 = 8, // Message "ASA active: For starting clutch kick"
	M9 = 9, // Message "ASA active: Air start Please Motor"
	M10 = 10, // Message "ASA Active: When leaving ignition off!"
	M11 = 11, // Message "ASA disabled"
	M12 = 12, // Message "ASA activated"
	M13 = 13, // Message "ASA: Display defective"
	M14 = 14, // not defined
	M15 = 15, // not defined
};

/** transmitter recognition */
enum class SBW_232h_SID_SBW {
	EWM = 0, // EWM
	MRM = 1, // MRM
	UNKNOWN_1 = 2, // not defined
	UNKNOWN_2 = 3, // not defined
};

/** Steering wheel keys "+", "-" actuated */
enum class SBW_232h_LRT_PM3 {
	NBET = 0, // not actuated
	PLUS = 1, // "+" actuated
	MINUS = 2, // "-" actuated
	PLUS_MINUS = 3, // "+" and "-" actuated
	UNKNOWN_1 = 4, // not defined
	UNKNOWN_2 = 5, // not defined
	UNKNOWN_3 = 6, // not defined
	SNV = 7, // signal not available
};

/** Shift-by-Wire control element ID */
enum class SBW_232h_SBWB_ID {
	GWHST_LR = 0, // GWHST_LR valid on bit 0..7 (old signal)
	RES_ALT_FEHLER = 2, // Reserved Old Signal "Error MRSM"
	SBWB_ST_P_RND = 3, // SBWB_ST P, RND valid on bit 0..5 (new signals)
};

/** Shift-by-Wire control P-button */
enum class SBW_232h_SBWB_ST_P {
	IDLE = 0, // P-button in rest position
	P = 1, // P button in "P" position
	INIT = 2, // P button initialization
	SNV = 3, // signal not available
};

/** Shift-by-Wire control Status RND */
enum class SBW_232h_SBWB_ST_RND {
	IDLE = 0, // SBW control in rest position
	R = 1, // SBW control in "R"
	N_OBEN = 2, // SBW control in "N above"
	N_UNTEN = 4, // SBW control in "N below"
	INIT = 6, // SBW control in initialization
	D = 8, // SBW control in "D"
	SNV = 15, // signal not available
};

/** Switching Difference Art */
enum class ART_250h_SLV_ART {
	SKL0 = 0, // Shift characteristic "0"
	SKL1 = 1, // Shift characteristic "1"
	SKL2 = 2, // Shift characteristic "2"
	SKL3 = 3, // Shift characteristic "3"
	SKL4 = 4, // Shift characteristic "4"
	SKL5 = 5, // Shift characteristic "5"
	SKL6 = 6, // Shift characteristic "6"
	SKL7 = 7, // Shift characteristic "7"
	SKL8 = 8, // Shift characteristic "8"
	SKL9 = 9, // Shift characteristic "9"
	SKL10 = 10, // Shift characteristic "10"
};

/** Gear, upper limit */
enum class ART_250h_GMAX_ART {
	PASSIVE = 0, // passive value
	G1 = 1, // Gear, upper limit = 1
	G2 = 2, // Gear, upper limit = 2
	G3 = 3, // Gear, upper limit = 3
	G4 = 4, // Gear, upper limit = 4
	G5 = 5, // Gear, upper limit = 5
	G6 = 6, // Gear, upper limit = 6
	G7 = 7, // Gear, upper limit = 7
};

/** Gear, lower limit */
enum class ART_250h_GMIN_ART {
	PASSIVE = 0, // passive value
	G1 = 1, // Gear, lower limit = 1
	G2 = 2, // Gear, lower limit = 2
	G3 = 3, // Gear, lower limit = 3
	G4 = 4, // Gear, lower limit = 4
	G5 = 5, // Gear, lower limit = 5
	G6 = 6, // Gear, lower limit = 6
	G7 = 7, // Gear, lower limit = 7
};

/** Art error code */
enum class ART_258h_ART_ERR {
	OK = 0, // No error available
	SCHMUTZ = 1, // ART disorder; Sensor dirty
	ART_DEF = 2, // Art defective
	ART_LIM_DEF = 3, // Art / Lim defective
	EXT = 4, // ART; External fault
	DBC_DEF = 5, // DBC defective
	SCHMUTZ_DBC_DEF = 6, // ART disorder; Sensor dirty and DBC defective
	ART_DBC_DEF = 7, // Type and DBC defective
	ART_LIM_DBC_DEF = 8, // Art / Lim and DBC defective
	EXT_DBC = 9, // Art external disorder and DBC defective
	UNKNOWN = 15, // not defined
};

/** Active function */
enum class ART_258h_ASSIST_FKT_AKT {
	AUS = 0, // out
	AAS = 1, // spacer wizard
	ADTR = 2, // Advanced DISTRONIC
	DBC = 3, // Downhill Brake Control
};

/** CAS Display request */
enum class ART_258h_CAS_ERR_ANZ_V2 {
	IDLE = 0, // No error
	CAS_SFV_REINIGEN = 1, // CAS Display "Clean bumper front"
	CAS_SFV_SFH_REINIGEN = 2, // CAS Display "Clean bumper front and rear"
	CAS_ERR_W = 3, // CAS Display "Workshop"
};

/** Assistance system Display request */
enum class ART_258h_ASSIST_ANZ_V2 {
	IDLE = 0, // basic picture according to active bit
	DBC_LIM = 1, // Message "Turn on DBC / DBC XX km / h"
	DBC_AUS = 2, // Message "Turn off DBC"
	DBC_AUS_TON = 3, // message "Switch off DBC" with sound
	DBC_NV_AKT = 4, // Message "DBC Missing / DBC Not Activable"
	DBC_NV_LIM = 5, // Message "DBC Missing / DBC XX km / h"
	AAS_EIN = 6, // Message "Turn on AAS"
	AAS_AUS = 7, // Message "Turn off AAS"
	AAS_AUS_TON = 8, // Message "Turn off AAS" with sound
	AAS_NV_LIM = 9, // Message "Do not turn on AAS activateable / LIM"
	AAS_NV_OBJ = 10, // Message "AAS not activateable / no destination"
	AAS_NV_FBED = 11, // Message "AAS incorrect operation / not available"
	AAS_FOLGEN = 12, // message "AAS destination goes on / follow"
	AAS_OBJ_VERLUST = 13, // message "AAS object loss"
	AAS_OBJ_WECHSEL = 14, // message "AAS new object / object change"
	PAS_EIN = 15, // message "PAS switch on / PAS active"
	PAS_AUS = 16, // Message "Turn off PAS / PAS"
	PAS_NV = 17, // message "PAS not activatable"
};

/** Current gear distribution gear */
enum class VG_428h_VG_GANG {
	SH_IPG = 0, // Switching is running (Shift in progress)
	LO = 1, // terrain (low range)
	HI = 2, // Road speed (High Range)
	N = 4, // Neutralgang (Not High Or Low Range)
	SNV = 7, // signal not available (signal not available)
};

/** VG request "N" */
enum class VG_428h_ANFN_VG {
	UNKNOWN = 0, // not defined
	ANF_N = 1, // requirement "neutral"
	IDLE = 2, // No requirement
	SNV = 3, // signal not available
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of ARCADE_A2 */
	uint32_t get_canid(){ return ARCADE_A2_CAN_ID; }
    /** Sets Confirm bit for all crazy events, tox */
    void set_CONF_CRASH(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Confirm bit for all crazy events, tox */
    bool get_CONF_CRASH() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Frontal event 2 */
    void set_CRASH_F(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Frontal event 2 */
    bool get_CRASH_F() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Frontal event 5 */
    void set_CRASH_C(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Frontal event 5 */
    bool get_CRASH_C() const { return (bool)(raw >> 58 & 0x1); }
        
} ARCADE_A2;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_ANZ */
	uint32_t get_canid(){ return MS_ANZ_CAN_ID; }
    /** Sets Number of ASA alert */
    void set_ASS_WARN(MS_ANZ_ASS_WARN value){ raw = (raw & 0xffff0fffffffffff) | ((uint64_t)value & 0xf) << 44; }

    /** Gets Number of ASA alert */
    MS_ANZ_ASS_WARN get_ASS_WARN() const { return (MS_ANZ_ASS_WARN)(raw >> 44 & 0xf); }
        
    /** Sets Number of ASA status message */
    void set_ASS_DSPL(MS_ANZ_ASS_DSPL value){ raw = (raw & 0xfffff0ffffffffff) | ((uint64_t)value & 0xf) << 40; }

    /** Gets Number of ASA status message */
    MS_ANZ_ASS_DSPL get_ASS_DSPL() const { return (MS_ANZ_ASS_DSPL)(raw >> 40 & 0xf); }
        
    /** Sets suppress lamp test during stop phase */
    void set_ASS_LTEST_AUS(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets suppress lamp test during stop phase */
    bool get_ASS_LTEST_AUS() const { return (bool)(raw >> 39 & 0x1); }
        
} MS_ANZ;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SBW_232 */
	uint32_t get_canid(){ return SBW_232_CAN_ID; }
    /** Sets transmitter recognition */
    void set_SID_SBW(SBW_232h_SID_SBW value){ raw = (raw & 0x3fffffffffffffff) | ((uint64_t)value & 0x3) << 62; }

    /** Gets transmitter recognition */
    SBW_232h_SID_SBW get_SID_SBW() const { return (SBW_232h_SID_SBW)(raw >> 62 & 0x3); }
        
    /** Sets Steering wheel keys "+", "-" actuated */
    void set_LRT_PM3(SBW_232h_LRT_PM3 value){ raw = (raw & 0xf8ffffffffffffff) | ((uint64_t)value & 0x7) << 56; }

    /** Gets Steering wheel keys "+", "-" actuated */
    SBW_232h_LRT_PM3 get_LRT_PM3() const { return (SBW_232h_LRT_PM3)(raw >> 56 & 0x7); }
        
    /** Sets Shift-by-Wire control element ID */
    void set_SBWB_ID(SBW_232h_SBWB_ID value){ raw = (raw & 0xff3fffffffffffff) | ((uint64_t)value & 0x3) << 54; }

    /** Gets Shift-by-Wire control element ID */
    SBW_232h_SBWB_ID get_SBWB_ID() const { return (SBW_232h_SBWB_ID)(raw >> 54 & 0x3); }
        
    /** Sets Shift-by-Wire control P-button */
    void set_SBWB_ST_P(SBW_232h_SBWB_ST_P value){ raw = (raw & 0xffcfffffffffffff) | ((uint64_t)value & 0x3) << 52; }

    /** Gets Shift-by-Wire control P-button */
    SBW_232h_SBWB_ST_P get_SBWB_ST_P() const { return (SBW_232h_SBWB_ST_P)(raw >> 52 & 0x3); }
        
    /** Sets Shift-by-Wire control Status RND */
    void set_SBWB_ST_RND(SBW_232h_SBWB_ST_RND value){ raw = (raw & 0xfff0ffffffffffff) | ((uint64_t)value & 0xf) << 48; }

    /** Gets Shift-by-Wire control Status RND */
    SBW_232h_SBWB_ST_RND get_SBWB_ST_RND() const { return (SBW_232h_SBWB_ST_RND)(raw >> 48 & 0xf); }
        
    /** Sets Message counter. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_BZ232h(uint8_t value){ raw = (raw & 0xffff0fffffffffff) | ((uint64_t)value & 0xf) << 44; }

    /** Gets Message counter. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_BZ232h() const { return (uint8_t)(raw >> 44 & 0xf); }
        
} SBW_232;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of ART_250 */
	uint32_t get_canid(){ return ART_250_CAN_ID; }
    /** Sets Switching Difference Art */
    void set_SLV_ART(ART_250h_SLV_ART value){ raw = (raw & 0x0fffffffffffffff) | ((uint64_t)value & 0xf) << 60; }

    /** Gets Switching Difference Art */
    ART_250h_SLV_ART get_SLV_ART() const { return (ART_250h_SLV_ART)(raw >> 60 & 0xf); }
        
    /** Sets Type in order */
    void set_ART_OK(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets Type in order */
    bool get_ART_OK() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Type brakes */
    void set_ART_BRE(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Type brakes */
    bool get_ART_BRE() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Brake light suppression */
    void set_BL_UNT(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Brake light suppression */
    bool get_BL_UNT() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Suppression Dynamic fully detection */
    void set_DYN_UNT(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets Suppression Dynamic fully detection */
    bool get_DYN_UNT() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets Engine torque Request Parity (just parity) */
    void set_MPAR_ART(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets Engine torque Request Parity (just parity) */
    bool get_MPAR_ART() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets Engine torque request dynamic */
    void set_MDYN_ART(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets Engine torque request dynamic */
    bool get_MDYN_ART() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets City Assistant regulates */
    void set_CAS_REG(bool value){ raw = (raw & 0xffdfffffffffffff) | ((uint64_t)value & 0x1) << 53; }

    /** Gets City Assistant regulates */
    bool get_CAS_REG() const { return (bool)(raw >> 53 & 0x1); }
        
    /** Sets Limiter regulates */
    void set_LIM_REG(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Limiter regulates */
    bool get_LIM_REG() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Type regulates */
    void set_ART_REG(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets Type regulates */
    bool get_ART_REG() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets Ford. Engine torque. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_M_ART(uint16_t value){ raw = (raw & 0xffffe000ffffffff) | ((uint64_t)value & 0x1fff) << 32; }

    /** Gets Ford. Engine torque. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_M_ART() const { return (uint16_t)(raw >> 32 & 0x1fff); }
        
    /** Sets Message counter. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_BZ250h(uint8_t value){ raw = (raw & 0xffffffff0fffffff) | ((uint64_t)value & 0xf) << 28; }

    /** Gets Message counter. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_BZ250h() const { return (uint8_t)(raw >> 28 & 0xf); }
        
    /** Sets brake torque (0000h: passive value). Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_MBRE_ART(uint16_t value){ raw = (raw & 0xfffffffff000ffff) | ((uint64_t)value & 0xfff) << 16; }

    /** Gets brake torque (0000h: passive value). Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_MBRE_ART() const { return (uint16_t)(raw >> 16 & 0xfff); }
        
    /** Sets Art desire: "Active recirculation" */
    void set_AKT_R_ART(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets Art desire: "Active recirculation" */
    bool get_AKT_R_ART() const { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets Gear, upper limit */
    void set_GMAX_ART(ART_250h_GMAX_ART value){ raw = (raw & 0xffffffffffffc7ff) | ((uint64_t)value & 0x7) << 11; }

    /** Gets Gear, upper limit */
    ART_250h_GMAX_ART get_GMAX_ART() const { return (ART_250h_GMAX_ART)(raw >> 11 & 0x7); }
        
    /** Sets Gear, lower limit */
    void set_GMIN_ART(ART_250h_GMIN_ART value){ raw = (raw & 0xfffffffffffff8ff) | ((uint64_t)value & 0x7) << 8; }

    /** Gets Gear, lower limit */
    ART_250h_GMIN_ART get_GMIN_ART() const { return (ART_250h_GMIN_ART)(raw >> 8 & 0x7); }
        
} ART_250;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of ART_258 */
	uint32_t get_canid(){ return ART_258_CAN_ID; }
    /** Sets Turn the display on type display */
    void set_ART_DSPL_EIN(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Turn the display on type display */
    bool get_ART_DSPL_EIN() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets detection standing object */
    void set_S_OBJ(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets detection standing object */
    bool get_S_OBJ() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Art Warning */
    void set_ART_WT(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Art Warning */
    bool get_ART_WT() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Art Infolampe */
    void set_ART_INFO(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Art Infolampe */
    bool get_ART_INFO() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Art error code */
    void set_ART_ERR(ART_258h_ART_ERR value){ raw = (raw & 0xf0ffffffffffffff) | ((uint64_t)value & 0xf) << 56; }

    /** Gets Art error code */
    ART_258h_ART_ERR get_ART_ERR() const { return (ART_258h_ART_ERR)(raw >> 56 & 0xf); }
        
    /** Sets set type speed. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_V_ART(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets set type speed. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_V_ART() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets distance relevant object. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_ABST_R_OBJ(uint8_t value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets distance relevant object. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_ABST_R_OBJ() const { return (uint8_t)(raw >> 40 & 0xff); }
        
    /** Sets driver request. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_SOLL_ABST(uint8_t value){ raw = (raw & 0xffffff00ffffffff) | ((uint64_t)value & 0xff) << 32; }

    /** Gets driver request. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_SOLL_ABST() const { return (uint8_t)(raw >> 32 & 0xff); }
        
    /** Sets Display "Winter tire limitation achieved" on the display */
    void set_ART_DSPL_PGB(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets Display "Winter tire limitation achieved" on the display */
    bool get_ART_DSPL_PGB() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets Display "DTR OFF [0]" on the display */
    void set_ART_VFBR(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets Display "DTR OFF [0]" on the display */
    bool get_ART_VFBR() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets Display "---" on the display */
    void set_ART_DSPL_LIM(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets Display "---" on the display */
    bool get_ART_DSPL_LIM() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets Spacer control mpomat turned on */
    void set_ART_EIN(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets Spacer control mpomat turned on */
    bool get_ART_EIN() const { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets Relevant object recognized */
    void set_OBJ_ERK(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets Relevant object recognized */
    bool get_OBJ_ERK() const { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets Turn on style segment display */
    void set_ART_SEG_EIN(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets Turn on style segment display */
    bool get_ART_SEG_EIN() const { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets Fluid indicator flash */
    void set_ART_DSPL_BL(bool value){ raw = (raw & 0xfffffffffdffffff) | ((uint64_t)value & 0x1) << 25; }

    /** Gets Fluid indicator flash */
    bool get_ART_DSPL_BL() const { return (bool)(raw >> 25 & 0x1); }
        
    /** Sets Art Tempomat on */
    void set_TM_EIN_ART(bool value){ raw = (raw & 0xfffffffffeffffff) | ((uint64_t)value & 0x1) << 24; }

    /** Gets Art Tempomat on */
    bool get_TM_EIN_ART() const { return (bool)(raw >> 24 & 0x1); }
        
    /** Sets Speed ​​recognized target vehicle. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_V_ZIEL(uint8_t value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Speed ​​recognized target vehicle. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_V_ZIEL() const { return (uint8_t)(raw >> 16 & 0xff); }
        
    /** Sets Minimum display time in the display new trigger */
    void set_ART_DSPL_NEU(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets Minimum display time in the display new trigger */
    bool get_ART_DSPL_NEU() const { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets Type is overplayed by the driver */
    void set_ART_UEBERSP(bool value){ raw = (raw & 0xffffffffffffbfff) | ((uint64_t)value & 0x1) << 14; }

    /** Gets Type is overplayed by the driver */
    bool get_ART_UEBERSP() const { return (bool)(raw >> 14 & 0x1); }
        
    /** Sets Display of system availability after system error */
    void set_ART_REAKT(bool value){ raw = (raw & 0xffffffffffffdfff) | ((uint64_t)value & 0x1) << 13; }

    /** Gets Display of system availability after system error */
    bool get_ART_REAKT() const { return (bool)(raw >> 13 & 0x1); }
        
    /** Sets Art distance warning is switched on */
    void set_ART_ABW_AKT(bool value){ raw = (raw & 0xffffffffffffefff) | ((uint64_t)value & 0x1) << 12; }

    /** Gets Art distance warning is switched on */
    bool get_ART_ABW_AKT() const { return (bool)(raw >> 12 & 0x1); }
        
    /** Sets Object Offer Spacer Wizard */
    void set_OBJ_AGB(bool value){ raw = (raw & 0xfffffffffffff7ff) | ((uint64_t)value & 0x1) << 11; }

    /** Gets Object Offer Spacer Wizard */
    bool get_OBJ_AGB() const { return (bool)(raw >> 11 & 0x1); }
        
    /** Sets LED spacer wizard flashing */
    void set_AAS_LED_BL(bool value){ raw = (raw & 0xfffffffffffffbff) | ((uint64_t)value & 0x1) << 10; }

    /** Gets LED spacer wizard flashing */
    bool get_AAS_LED_BL() const { return (bool)(raw >> 10 & 0x1); }
        
    /** Sets Active function */
    void set_ASSIST_FKT_AKT(ART_258h_ASSIST_FKT_AKT value){ raw = (raw & 0xfffffffffffffcff) | ((uint64_t)value & 0x3) << 8; }

    /** Gets Active function */
    ART_258h_ASSIST_FKT_AKT get_ASSIST_FKT_AKT() const { return (ART_258h_ASSIST_FKT_AKT)(raw >> 8 & 0x3); }
        
    /** Sets CAS Display request */
    void set_CAS_ERR_ANZ_V2(ART_258h_CAS_ERR_ANZ_V2 value){ raw = (raw & 0xffffffffffffff1f) | ((uint64_t)value & 0x7) << 5; }

    /** Gets CAS Display request */
    ART_258h_CAS_ERR_ANZ_V2 get_CAS_ERR_ANZ_V2() const { return (ART_258h_CAS_ERR_ANZ_V2)(raw >> 5 & 0x7); }
        
    /** Sets Assistance system Display request */
    void set_ASSIST_ANZ_V2(ART_258h_ASSIST_ANZ_V2 value){ raw = (raw & 0xffffffffffffffe0) | ((uint64_t)value & 0x1f) << 0; }

    /** Gets Assistance system Display request */
    ART_258h_ASSIST_ANZ_V2 get_ASSIST_ANZ_V2() const { return (ART_258h_ASSIST_ANZ_V2)(raw >> 0 & 0x1f); }
        
} ART_258;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of PSM_3B4 */
	uint32_t get_canid(){ return PSM_3B4_CAN_ID; }
    /** Sets Work Speed Control - ParityBit */
    void set_PSM_ADR_PAR(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Work Speed Control - ParityBit */
    bool get_PSM_ADR_PAR() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Labor speed control - Togglebit */
    void set_PSM_ADR_TGL(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Labor speed control - Togglebit */
    bool get_PSM_ADR_TGL() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets working speed control active */
    void set_PSM_ADR_AKT(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets working speed control active */
    bool get_PSM_ADR_AKT() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Motoroll speed ADR. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_PSM_N_SOLL(uint16_t value){ raw = (raw & 0xff0000ffffffffff) | ((uint64_t)value & 0xffff) << 40; }

    /** Gets Motoroll speed ADR. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_PSM_N_SOLL() const { return (uint16_t)(raw >> 40 & 0xffff); }
        
    /** Sets Tomentic limitation - parity bit */
    void set_PSM_MOM_PAR(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets Tomentic limitation - parity bit */
    bool get_PSM_MOM_PAR() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets Tomentic limitation - Togglebit */
    void set_PSM_MOM_TGL(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets Tomentic limitation - Togglebit */
    bool get_PSM_MOM_TGL() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets Tomentic limitation active */
    void set_PSM_MOM_AKT(bool value){ raw = (raw & 0xffffffdfffffffff) | ((uint64_t)value & 0x1) << 37; }

    /** Gets Tomentic limitation active */
    bool get_PSM_MOM_AKT() const { return (bool)(raw >> 37 & 0x1); }
        
    /** Sets Maximum engine torque. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_PSM_MOM_SOLL(uint16_t value){ raw = (raw & 0xffffffe000ffffff) | ((uint64_t)value & 0x1fff) << 24; }

    /** Gets Maximum engine torque. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_PSM_MOM_SOLL() const { return (uint16_t)(raw >> 24 & 0x1fff); }
        
    /** Sets Speed limitation - parity bit */
    void set_PSM_DZ_PAR(bool value){ raw = (raw & 0xffffffffff7fffff) | ((uint64_t)value & 0x1) << 23; }

    /** Gets Speed limitation - parity bit */
    bool get_PSM_DZ_PAR() const { return (bool)(raw >> 23 & 0x1); }
        
    /** Sets Speed limitation - Togglebit */
    void set_PSM_DZ_TGL(bool value){ raw = (raw & 0xffffffffffbfffff) | ((uint64_t)value & 0x1) << 22; }

    /** Gets Speed limitation - Togglebit */
    bool get_PSM_DZ_TGL() const { return (bool)(raw >> 22 & 0x1); }
        
    /** Sets Speed limitation active */
    void set_PSM_DZ_AKT(bool value){ raw = (raw & 0xffffffffffdfffff) | ((uint64_t)value & 0x1) << 21; }

    /** Gets Speed limitation active */
    bool get_PSM_DZ_AKT() const { return (bool)(raw >> 21 & 0x1); }
        
    /** Sets Maximum speed. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_PSM_DZ_MAX(uint16_t value){ raw = (raw & 0xffffffffffff0000) | ((uint64_t)value & 0xffff) << 0; }

    /** Gets Maximum speed. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_PSM_DZ_MAX() const { return (uint16_t)(raw >> 0 & 0xffff); }
        
} PSM_3B4;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of PSM_3B8 */
	uint32_t get_canid(){ return PSM_3B8_CAN_ID; }
    /** Sets Speed Control - Parity Bit */
    void set_PSM_V_PAR(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Speed Control - Parity Bit */
    bool get_PSM_V_PAR() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Speed limitation - Togglebit */
    void set_PSM_V_TGL(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Speed limitation - Togglebit */
    bool get_PSM_V_TGL() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Speed limitation active */
    void set_PSM_V_AKT(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Speed limitation active */
    bool get_PSM_V_AKT() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Speed limit. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_PSM_V_SOLL(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Speed limit. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_PSM_V_SOLL() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Speed limitation - parity bit */
    void set_PSM_DZ_PAR(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Speed limitation - parity bit */
    bool get_PSM_DZ_PAR() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Speed limitation - Togglebit */
    void set_PSM_DZ_TGL(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Speed limitation - Togglebit */
    bool get_PSM_DZ_TGL() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Motor Remote Start active */
    void set_PSM_FERN_START(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets Motor Remote Start active */
    bool get_PSM_FERN_START() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets Motor Remote Stop active */
    void set_PSM_FERN_STOP(bool value){ raw = (raw & 0xffffefffffffffff) | ((uint64_t)value & 0x1) << 44; }

    /** Gets Motor Remote Stop active */
    bool get_PSM_FERN_STOP() const { return (bool)(raw >> 44 & 0x1); }
        
    /** Sets lock accelerator pedal module */
    void set_PSM_FPM_SP(bool value){ raw = (raw & 0xfffff7ffffffffff) | ((uint64_t)value & 0x1) << 43; }

    /** Gets lock accelerator pedal module */
    bool get_PSM_FPM_SP() const { return (bool)(raw >> 43 & 0x1); }
        
} PSM_3B8;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of VG_428 */
	uint32_t get_canid(){ return VG_428_CAN_ID; }
    /** Sets Error VG (ECU Failure Detected) */
    void set_VG_ERR(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Error VG (ECU Failure Detected) */
    bool get_VG_ERR() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Current gear distribution gear */
    void set_VG_GANG(VG_428h_VG_GANG value){ raw = (raw & 0xf8ffffffffffffff) | ((uint64_t)value & 0x7) << 56; }

    /** Gets Current gear distribution gear */
    VG_428h_VG_GANG get_VG_GANG() const { return (VG_428h_VG_GANG)(raw >> 56 & 0x7); }
        
    /** Sets VG - Request "n" Parity (straight parity) */
    void set_ANFNPAR_VG(bool value){ raw = (raw & 0xfff7ffffffffffff) | ((uint64_t)value & 0x1) << 51; }

    /** Gets VG - Request "n" Parity (straight parity) */
    bool get_ANFNPAR_VG() const { return (bool)(raw >> 51 & 0x1); }
        
    /** Sets VG - ANG.Load "N" Toggle 20ms (1 / Embassy) */
    void set_ANFNTGL_VG(bool value){ raw = (raw & 0xfffbffffffffffff) | ((uint64_t)value & 0x1) << 50; }

    /** Gets VG - ANG.Load "N" Toggle 20ms (1 / Embassy) */
    bool get_ANFNTGL_VG() const { return (bool)(raw >> 50 & 0x1); }
        
    /** Sets VG request "N" */
    void set_ANFN_VG(VG_428h_ANFN_VG value){ raw = (raw & 0xfffcffffffffffff) | ((uint64_t)value & 0x3) << 48; }

    /** Gets VG request "N" */
    VG_428h_ANFN_VG get_ANFN_VG() const { return (VG_428h_ANFN_VG)(raw >> 48 & 0x3); }
        
} VG_428;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of LWR_530 */
	uint32_t get_canid(){ return LWR_530_CAN_ID; }
    /** Sets Display message 7: "Baltic view currently not available" */
    void set_LWR_M7(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Display message 7: "Baltic view currently not available" */
    bool get_LWR_M7() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Display message 6: "Bolt match right" */
    void set_LWR_M6(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Display message 6: "Bolt match right" */
    bool get_LWR_M6() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Display message 5: "Bolt view left" */
    void set_LWR_M5(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Display message 5: "Bolt view left" */
    bool get_LWR_M5() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Display message 4: "Curve light currently not available" (white / 5x flashing with 1Hz) */
    void set_LWR_M4(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets Display message 4: "Curve light currently not available" (white / 5x flashing with 1Hz) */
    bool get_LWR_M4() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Display message 3: "Curve light currently not available" (white). */
    void set_LWR_M3(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Display message 3: "Curve light currently not available" (white). */
    bool get_LWR_M3() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Display message 2: "Curve light, replacement light activated!"(White) */
    void set_LWR_M2(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Display message 2: "Curve light, replacement light activated!"(White) */
    bool get_LWR_M2() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Display message 1: "Curve light defective! Drive to the workshop" */
    void set_LWR_M1(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets Display message 1: "Curve light defective! Drive to the workshop" */
    bool get_LWR_M1() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets Substitution lowlight left */
    void set_SUB_ABL_L(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets Substitution lowlight left */
    bool get_SUB_ABL_L() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets Substitution low beam right */
    void set_SUB_ABL_R(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets Substitution low beam right */
    bool get_SUB_ABL_R() const { return (bool)(raw >> 54 & 0x1); }
        
} LWR_530;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of CONFIG_6FF */
	uint32_t get_canid(){ return CONFIG_6FF_CAN_ID; }
    /** Sets E-suction fan: basic ventilation */
    void set_GBL_AUS(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets E-suction fan: basic ventilation */
    bool get_GBL_AUS() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Air conditioning available */
    void set_KLA_VH(bool value){ raw = (raw & 0xffffffffffffdfff) | ((uint64_t)value & 0x1) << 13; }

    /** Gets Air conditioning available */
    bool get_KLA_VH() const { return (bool)(raw >> 13 & 0x1); }
        
    /** Sets Differential lock behind available */
    void set_DSH_VH(bool value){ raw = (raw & 0xfffffffffffffff7) | ((uint64_t)value & 0x1) << 3; }

    /** Gets Differential lock behind available */
    bool get_DSH_VH() const { return (bool)(raw >> 3 & 0x1); }
        
    /** Sets Differential lock center available */
    void set_DSM_VH(bool value){ raw = (raw & 0xfffffffffffffffb) | ((uint64_t)value & 0x1) << 2; }

    /** Gets Differential lock center available */
    bool get_DSM_VH() const { return (bool)(raw >> 2 & 0x1); }
        
    /** Sets Differential lock in front available */
    void set_DSV_VH(bool value){ raw = (raw & 0xfffffffffffffffd) | ((uint64_t)value & 0x1) << 1; }

    /** Gets Differential lock in front available */
    bool get_DSV_VH() const { return (bool)(raw >> 1 & 0x1); }
        
    /** Sets distribution gear control available */
    void set_VG_VH(bool value){ raw = (raw & 0xfffffffffffffffe) | ((uint64_t)value & 0x1) << 0; }

    /** Gets distribution gear control available */
    bool get_VG_VH() const { return (bool)(raw >> 0 & 0x1); }
        
} CONFIG_6FF;



class ECU_ANY_ECU {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case ARCADE_A2_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case MS_ANZ_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                case SBW_232_CAN_ID:
                    LAST_FRAME_TIMES[2] = timestamp_now;
                    FRAME_DATA[2] = value;
                    return true;
                case ART_250_CAN_ID:
                    LAST_FRAME_TIMES[3] = timestamp_now;
                    FRAME_DATA[3] = value;
                    return true;
                case ART_258_CAN_ID:
                    LAST_FRAME_TIMES[4] = timestamp_now;
                    FRAME_DATA[4] = value;
                    return true;
                case PSM_3B4_CAN_ID:
                    LAST_FRAME_TIMES[5] = timestamp_now;
                    FRAME_DATA[5] = value;
                    return true;
                case PSM_3B8_CAN_ID:
                    LAST_FRAME_TIMES[6] = timestamp_now;
                    FRAME_DATA[6] = value;
                    return true;
                case VG_428_CAN_ID:
                    LAST_FRAME_TIMES[7] = timestamp_now;
                    FRAME_DATA[7] = value;
                    return true;
                case LWR_530_CAN_ID:
                    LAST_FRAME_TIMES[8] = timestamp_now;
                    FRAME_DATA[8] = value;
                    return true;
                case CONFIG_6FF_CAN_ID:
                    LAST_FRAME_TIMES[9] = timestamp_now;
                    FRAME_DATA[9] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to ARCADE_A2
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ARCADE_A2(uint64_t now, uint64_t max_expire_time, ARCADE_A2* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[0] && now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_ANZ
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_ANZ(uint64_t now, uint64_t max_expire_time, MS_ANZ* dest) const {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[1] && now - LAST_FRAME_TIMES[1] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[1];
                return true;
            }
        }
            
        /** Sets data in pointer to SBW_232
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SBW_232(uint64_t now, uint64_t max_expire_time, SBW_232* dest) const {
            if (LAST_FRAME_TIMES[2] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[2] && now - LAST_FRAME_TIMES[2] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[2];
                return true;
            }
        }
            
        /** Sets data in pointer to ART_250
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ART_250(uint64_t now, uint64_t max_expire_time, ART_250* dest) const {
            if (LAST_FRAME_TIMES[3] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[3] && now - LAST_FRAME_TIMES[3] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[3];
                return true;
            }
        }
            
        /** Sets data in pointer to ART_258
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ART_258(uint64_t now, uint64_t max_expire_time, ART_258* dest) const {
            if (LAST_FRAME_TIMES[4] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[4] && now - LAST_FRAME_TIMES[4] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[4];
                return true;
            }
        }
            
        /** Sets data in pointer to PSM_3B4
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_PSM_3B4(uint64_t now, uint64_t max_expire_time, PSM_3B4* dest) const {
            if (LAST_FRAME_TIMES[5] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[5] && now - LAST_FRAME_TIMES[5] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[5];
                return true;
            }
        }
            
        /** Sets data in pointer to PSM_3B8
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_PSM_3B8(uint64_t now, uint64_t max_expire_time, PSM_3B8* dest) const {
            if (LAST_FRAME_TIMES[6] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[6] && now - LAST_FRAME_TIMES[6] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[6];
                return true;
            }
        }
            
        /** Sets data in pointer to VG_428
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_VG_428(uint64_t now, uint64_t max_expire_time, VG_428* dest) const {
            if (LAST_FRAME_TIMES[7] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[7] && now - LAST_FRAME_TIMES[7] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[7];
                return true;
            }
        }
            
        /** Sets data in pointer to LWR_530
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_LWR_530(uint64_t now, uint64_t max_expire_time, LWR_530* dest) const {
            if (LAST_FRAME_TIMES[8] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[8] && now - LAST_FRAME_TIMES[8] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[8];
                return true;
            }
        }
            
        /** Sets data in pointer to CONFIG_6FF
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_CONFIG_6FF(uint64_t now, uint64_t max_expire_time, CONFIG_6FF* dest) const {
            if (LAST_FRAME_TIMES[9] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[9] && now - LAST_FRAME_TIMES[9] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[9];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[10];
		uint64_t LAST_FRAME_TIMES[10];
};
#endif // __ECU_ANY_ECU_H_