
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'EZS'
*/

#ifndef __ECU_EZS_H_
#define __ECU_EZS_H_

#include <stdint.h>
    
#define EZS_240_EGS52_CAN_ID 0x0240
#define ZGW_248_EGS52_CAN_ID 0x0248
#define ZGW_24C_EGS52_CAN_ID 0x024C
#define KLA_410_EGS52_CAN_ID 0x0410

/** LHD / RHD */
enum class EZS_240h_LL_RLC_EGS52 : uint16_t {
	UNKNOWN = 0, // not defined
	LL = 1, // Left
	RL = 2, // RHD
	SNV = 3, // Code not available
};

/** ESP on / off operated */
enum class EZS_240h_ESP_BET_EGS52 : uint16_t {
	NBET = 0, // Not operated (rocker and push-push)
	AUS_BET = 1, // ESP from operated (rocker) operated (Push Push)
	EIN_NDEF = 2, // ESP a pressed (rocker) is not defined (push-push)
	SNV = 3, // No signal (rocker and push-push)
};

/** LF / ABC 2-stage switch actuated */
enum class EZS_240h_ST2_BET_EGS52 : uint16_t {
	NBET = 0, // Not operated (rocker and push-push)
	UNBET_NDEF = 1, // Down actuated (rocker) Not defined (push-push)
	OBBET_BET = 2, // Top operated (rocker), actuated (push-push)
	UNKNOWN = 3, // Not defined (rocker and push-push)
};

/** LF / ABC 3-position switch is actuated */
enum class EZS_240h_ST3_BET_EGS52 : uint16_t {
	NBET = 0, // Not operated (rocker and push-push)
	UNBET_NDEF = 1, // Down actuated (rocker) Not defined (push-push)
	OBBET_BET = 2, // Top operated (rocker), actuated (push-push)
	UNKNOWN = 3, // Not defined (rocker and push-push)
};

/** ART-distance warning actuated on / off */
enum class EZS_240h_ART_ABW_BET_EGS52 : uint16_t {
	NDEF_NBET = 0, // not defined (rocker), non-actuated (push-push)
	AUS_NDEF = 1, // distance warning (rocker) not defined (Push Push)
	EIN_BET = 2, // distance warning a (rocker) operated (Push Push)
	SNV = 3, // No signal (rocker and push-push)
};

/** Series addicts vehicle version (only 220/215/230) */
enum class EZS_240h_FZGVERSN_EGS52 : uint16_t {
	START = 0, // Stand at launch of the respective series
	V1 = 1, // BR 220: EJ 99 / X, C215: EJ 01/1, R230: EJ 02/1
	V2 = 2, // BR 220: EJ 1.1, C215: EJ 02 / X, R230: EJ 03 / X
	V3 = 3, // BR 220: EJ 02 / X, C215: EJ 03 / X, R230: not defined
	V4 = 4, // BR 220: prohibited C215 / R230: undefined
	V5 = 5, // BR 220: prohibited C215 / R230: undefined
	V6 = 6, // BR 220: EJ 03 / X, C215 / R230: undefined
	V7 = 7, // BR 220 / C215 / R230: undefined
};

/** country code */
enum class EZS_240h_LDC_EGS52 : uint16_t {
	RDW = 0, // Rest of the World
	USA_CAN = 1, // USA / Canada
	UNKNOWN = 2, // not defined
	SNV = 3, // Code not available
};

/** trailer operation recognized */
enum class ZGW_248h_ANH_ERK2_EGS52 : uint16_t {
	KEIN = 0, // Pendant not recognized
	OK = 1, // trailer recognized
	UNKNOWN = 2, // not defined
	SNV = 3, // signal not available
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** country code **/
		EZS_240h_LDC_EGS52 LDC: 2;
		/** Series addicts vehicle version (only 220/215/230) **/
		EZS_240h_FZGVERSN_EGS52 FZGVERSN: 3;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		bool __PADDING1__: 1;
		/** E-extractor: basic ventilation from **/
		bool GBL_AUS: 1;
		/** ART available **/
		bool ART_VH: 1;
		/** spacing factor **/
		uint8_t ART_ABSTAND: 8;
		/** Terminal 54 Hardware enabled **/
		bool KL54_RM: 1;
		/** Switch on low beam **/
		bool ABL_EIN: 1;
		/** ART-distance warning actuated on / off **/
		EZS_240h_ART_ABW_BET_EGS52 ART_ABW_BET: 2;
		/** LF / ABC 3-position switch is actuated **/
		EZS_240h_ST3_BET_EGS52 ST3_BET: 2;
		/** LF / ABC 2-stage switch actuated **/
		EZS_240h_ST2_BET_EGS52 ST2_BET: 2;
		/** directional blinking left **/
		bool BLI_LI: 1;
		/** directional blinking right **/
		bool BLI_RE: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		bool __PADDING2__: 1;
		/** Wiper outside parking position **/
		bool KL_31B: 1;
		/** attracted hand brake (control light) **/
		bool HAS_KL: 1;
		/** ESP on / off operated **/
		EZS_240h_ESP_BET_EGS52 ESP_BET: 2;
		/** Wiring emergency: Prio1- and Prio2-consumers, Second battery supports **/
		bool BN_NTLF: 1;
		/** Crash signal from airbag SG **/
		bool CRASH: 1;
		/** CRASH Confirmbit **/
		bool CRASH_CNF: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING3__: 2;
		/** ASG Sport mode on / off operated (ST2_LED_DL when ABC available) **/
		bool ASG_SPORT_BET: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING4__: 3;
		/** Message counter **/
		uint8_t BZ240h: 4;
		/** cruise control lever parity (even parity) **/
		bool WH_PA: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING5__: 3;
		/** Terminal 50 **/
		bool KL_50: 1;
		/** Terminal 15 **/
		bool KL_15: 1;
		/** brake switch for Shift Lock **/
		bool BS_SL: 1;
		/** Reverse gear engaged (manual transmission only) **/
		bool RG_SCHALT: 1;
		/** LHD / RHD **/
		EZS_240h_LL_RLC_EGS52 LL_RLC: 2;
		/** meets Keyles Go annealing conditions **/
		bool KG_ALB_OK: 1;
		/** Keyless Go terminal control active **/
		bool KG_KL_AKT: 1;
		/** cruise control lever "off" **/
		bool AUS: 1;
		/** cruise control lever: "resume" **/
		bool WA: 1;
		/** cruise control lever: "Sit and accelerating Stufe0" **/
		bool S_PLUS_B: 1;
		/** cruise control lever: "Sit and delay Stufe0" **/
		bool S_MINUS_B: 1;
		/** Operation variable speed limit **/
		bool VMAX_AKT: 1;
		/** cruise control lever implausible **/
		bool WH_UP: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING6__: 2;
	} __attribute__((packed));
	/** Gets CAN ID of EZS_240_EGS52 **/
	uint32_t get_canid(){ return EZS_240_EGS52_CAN_ID; }
} EZS_240_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint64_t __PADDING1__: 48;
		/** trailer operation recognized **/
		ZGW_248h_ANH_ERK2_EGS52 ANH_ERK2: 2;
		/** Auxiliary water pump is running **/
		bool ZWP_LFT: 1;
		/** AFL requirement: Switch on low beam **/
		bool AFL_ABL_EIN: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING2__: 8;
		/** Switch on low beam **/
		bool ABL_EIN: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		bool __PADDING3__: 1;
		/** Start Xenon4 diagnostic procedure driver side **/
		bool DIAG_X4_F: 1;
		/** Start Xenon4 diagnostic procedure passenger side **/
		bool DIAG_X4_B: 1;
	} __attribute__((packed));
	/** Gets CAN ID of ZGW_248_EGS52 **/
	uint32_t get_canid(){ return ZGW_248_EGS52_CAN_ID; }
} ZGW_248_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint32_t __PADDING1__: 24;
		/** Low beam defective driver / left (depending on BR) **/
		bool ABL_DEF_F_L: 1;
		/** Low beam defective front passenger / right (depending on BR) **/
		bool ABL_DEF_BF_R: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint64_t __PADDING2__: 38;
	} __attribute__((packed));
	/** Gets CAN ID of ZGW_24C_EGS52 **/
	uint32_t get_canid(){ return ZGW_24C_EGS52_CAN_ID; }
} ZGW_24C_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint16_t __PADDING1__: 16;
		/** Outdoor air temperature for thermal management **/
		uint8_t T_AUSSEN_WM: 8;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING2__: 8;
		/** Motor fan setpoint speed **/
		uint8_t NLFTS: 8;
		/** Torque recording refrigeration compressor **/
		uint8_t M_KOMP: 8;
		/** refrigerant printing **/
		uint8_t P_KAELTE8: 8;
		/** climate compressor turned on **/
		bool KOMP_EIN: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING3__: 5;
		/** idle speed lifting to the cooling power increase **/
		bool LL_DZA: 1;
		/** Climate Compressor Tour NEW **/
		uint8_t M_KOMP_NEU: 8;
		/** Climate Compressor Tour Toggle **/
		bool M_KOMPTGL: 1;
		/** Climate Compressor Torque Parity (straight parity) **/
		bool M_KOMPPAR: 1;
		/** signal version Compressor torque **/
		bool SENDE_NEU: 1;
		/** Turn on a heater **/
		bool ZH_EIN_OK: 1;
	} __attribute__((packed));
	/** Gets CAN ID of KLA_410_EGS52 **/
	uint32_t get_canid(){ return KLA_410_EGS52_CAN_ID; }
} KLA_410_EGS52;



class ECU_EZS {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            uint8_t idx = 0;
            bool add = true;
            switch(can_id) {
                case EZS_240_EGS52_CAN_ID:
                    idx = 0;
                    break;
                case ZGW_248_EGS52_CAN_ID:
                    idx = 1;
                    break;
                case ZGW_24C_EGS52_CAN_ID:
                    idx = 2;
                    break;
                case KLA_410_EGS52_CAN_ID:
                    idx = 3;
                    break;
                default:
                    add = false;
                    break;
            }
            if (add) {
                LAST_FRAME_TIMES[idx] = timestamp_now;
                FRAME_DATA[idx] = value;
            }
            return add;
        }
        
        /** Sets data in pointer to EZS_240
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_EZS_240(uint64_t now, uint64_t max_expire_time, EZS_240_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[0] <= now && now - LAST_FRAME_TIMES[0] < max_expire_time) {
                dest->raw = FRAME_DATA[0];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to ZGW_248
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ZGW_248(uint64_t now, uint64_t max_expire_time, ZGW_248_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[1] <= now && now - LAST_FRAME_TIMES[1] < max_expire_time) {
                dest->raw = FRAME_DATA[1];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to ZGW_24C
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ZGW_24C(uint64_t now, uint64_t max_expire_time, ZGW_24C_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[2] <= now && now - LAST_FRAME_TIMES[2] < max_expire_time) {
                dest->raw = FRAME_DATA[2];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to KLA_410
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_KLA_410(uint64_t now, uint64_t max_expire_time, KLA_410_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[3] <= now && now - LAST_FRAME_TIMES[3] < max_expire_time) {
                dest->raw = FRAME_DATA[3];
                ret = true;
            }
            return ret;
        }
            
	private:
		uint64_t FRAME_DATA[4];
		uint64_t LAST_FRAME_TIMES[4];
};
#endif // __ECU_EZS_H_