
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'MRM'
*/

#ifndef __ECU_MRM_H_
#define __ECU_MRM_H_

#include <stdint.h>
    
#define LRW_236_EGS52_CAN_ID 0x0236
#define MRM_238_EGS52_CAN_ID 0x0238

/** Identification steering wheel angle sensor */
enum class LRW_236h_LRWS_ID_EGS52 : uint16_t {
	INIT_PSBL = 0, // LRW sensor is initializable
	INIT_SELF = 1, // LRW sensor initializes itself
	INIT_MUST = 2, // (LRW sensor must be initialized)
	SNV = 3, // signal not available
};

/** Status steering wheel angle sensor */
enum class LRW_236h_LRWS_ST_EGS52 : uint16_t {
	OK = 0, // Steering wheel angle sensor I.O.
	INI = 1, // Steering wheel angle sensor not initialized
	ERR = 2, // steering wheel angle sensor faulty
	ERR_INI = 3, // steering wheel angle sensor faulty and not initialized
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** CRC checksum byte 1 - 7 to SAE J1850 **/
		uint8_t CRC236h: 8;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint16_t __PADDING1__: 16;
		/** Status steering wheel angle sensor **/
		LRW_236h_LRWS_ST_EGS52 LRWS_ST: 2;
		/** Identification steering wheel angle sensor **/
		LRW_236h_LRWS_ID_EGS52 LRWS_ID: 2;
		/** Message counter **/
		uint8_t BZ236h: 4;
		/** steering wheel angular velocity **/
		uint16_t VLRW: 14;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING2__: 2;
		/** Steering wheel angle **/
		uint16_t LRW: 14;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING3__: 2;
	} __attribute__((packed));
	/** Gets CAN ID of LRW_236_EGS52 **/
	uint32_t get_canid(){ return LRW_236_EGS52_CAN_ID; }
} LRW_236_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint32_t __PADDING1__: 32;
		/** steering angle **/
		uint16_t LW: 11;
		/** Steering angle sign **/
		bool LW_VZ: 1;
		/** Steering angle sensor: not initialized **/
		bool LW_INI: 1;
		/** Steering angle sensor: Code error **/
		bool LW_CF: 1;
		/** Steering angle sensor: overflow **/
		bool LW_OV: 1;
		/** Steering angle parity (straight parity) **/
		bool LW_PA: 1;
		/** Message counter **/
		uint8_t BZ238h: 4;
		/** Tempomat selector lever Parity (straight parity) **/
		bool WH_PA: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		bool __PADDING2__: 1;
		/** direction flash left **/
		bool BLI_LI: 1;
		/** directional flashing right **/
		bool BLI_RE: 1;
		/** Tempomat selector lever: "Switch off" **/
		bool AUS: 1;
		/** Cruise control lever: "Recovery" **/
		bool WA: 1;
		/** Tempomat selector lever: "Setting and Accelerating Level0" **/
		bool S_PLUS_B: 1;
		/** Tempomatwatch Lever: "Setting and delaying Levo0" **/
		bool S_MINUS_B: 1;
		/** Operation variable speed limitation **/
		bool VMAX_AKT: 1;
		/** Tempomat selector lever unplausible **/
		bool WH_UP: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING3__: 2;
	} __attribute__((packed));
	/** Gets CAN ID of MRM_238_EGS52 **/
	uint32_t get_canid(){ return MRM_238_EGS52_CAN_ID; }
} MRM_238_EGS52;



class ECU_MRM {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint32_t timestamp_now) {
            uint8_t idx = 0;
            bool add = true;
            switch(can_id) {
                case LRW_236_EGS52_CAN_ID:
                    idx = 0;
                    break;
                case MRM_238_EGS52_CAN_ID:
                    idx = 1;
                    break;
                default:
                    add = false;
                    break;
            }
            if (add) {
                LAST_FRAME_TIMES[idx] = timestamp_now;
                FRAME_DATA[idx] = value;
            }
            return add;
        }
        
        /** Sets data in pointer to LRW_236
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_LRW_236(const uint32_t now, const uint32_t max_expire_time, LRW_236_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[0] <= now && now - LAST_FRAME_TIMES[0] < max_expire_time) {
                dest->raw = FRAME_DATA[0];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to MRM_238
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MRM_238(const uint32_t now, const uint32_t max_expire_time, MRM_238_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[1] <= now && now - LAST_FRAME_TIMES[1] < max_expire_time) {
                dest->raw = FRAME_DATA[1];
                ret = true;
            }
            return ret;
        }
            
	private:
		uint64_t FRAME_DATA[2];
		uint32_t LAST_FRAME_TIMES[2];
};
#endif // __ECU_MRM_H_