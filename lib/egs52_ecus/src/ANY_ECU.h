
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'ANY_ECU'
*/

#ifndef __ECU_ANY_ECU_H_
#define __ECU_ANY_ECU_H_

#include <stdint.h>
    
#define ARCADE_A2_EGS52_CAN_ID 0x0035
#define MS_ANZ_EGS52_CAN_ID 0x033D
#define SBW_232_EGS52_CAN_ID 0x0232
#define ART_250_EGS52_CAN_ID 0x0250
#define ART_258_EGS52_CAN_ID 0x0258
#define PSM_3B4_EGS52_CAN_ID 0x03B4
#define PSM_3B8_EGS52_CAN_ID 0x03B8
#define VG_428_EGS52_CAN_ID 0x0428
#define LWR_530_EGS52_CAN_ID 0x0530
#define CONFIG_6FF_EGS52_CAN_ID 0x06FF

/** Number of ASA alert */
enum class MS_ANZ_ASS_WARN_EGS52 : uint16_t {
	IDLE = 0, // No status / warning
	M1 = 1, // Message "ASA inactive: warming up the engine"
	M2 = 2, // Message "ASA Active driving"
	M3 = 3, // Message "ASA Active stop mode"
	M4 = 4, // Message "ASA switched off: electrical power supplies"
	M5 = 5, // Message "ASA switched off: air conditioner"
	M6 = 6, // Message "ASA not active: Fault"
	M7 = 7, // Message "ASA Active electrical energy demand, Please start engine"
	M8 = 8, // Message "ASA active: For starting clutch kick"
	M9 = 9, // Message "ASA active: Air start Please Motor"
	M10 = 10, // Message "ASA Active: When leaving ignition off!"
	M11 = 11, // Message "ASA disabled"
	M12 = 12, // Message "ASA activated"
	M13 = 13, // Message "ASA: Display defective"
	M14 = 14, // not defined
	M15 = 15, // not defined
};

/** Number of ASA status message */
enum class MS_ANZ_ASS_DSPL_EGS52 : uint16_t {
	IDLE = 0, // No status / warning
	M1 = 1, // Message "ASA inactive: warming up the engine"
	M2 = 2, // Message "ASA Active driving"
	M3 = 3, // Message "ASA Active stop mode"
	M4 = 4, // Message "ASA switched off: electrical power supplies"
	M5 = 5, // Message "ASA switched off: air conditioner"
	M6 = 6, // Message "ASA not active: Fault"
	M7 = 7, // Message "ASA Active electrical energy demand, Please start engine"
	M8 = 8, // Message "ASA active: For starting clutch kick"
	M9 = 9, // Message "ASA active: Air start Please Motor"
	M10 = 10, // Message "ASA Active: When leaving ignition off!"
	M11 = 11, // Message "ASA disabled"
	M12 = 12, // Message "ASA activated"
	M13 = 13, // Message "ASA: Display defective"
	M14 = 14, // not defined
	M15 = 15, // not defined
};

/** transmitter recognition */
enum class SBW_232h_SID_SBW_EGS52 : uint16_t {
	EWM = 0, // EWM
	MRM = 1, // MRM
	UNKNOWN_1 = 2, // not defined
	UNKNOWN_2 = 3, // not defined
};

/** Steering wheel keys "+", "-" actuated */
enum class SBW_232h_LRT_PM3_EGS52 : uint16_t {
	NBET = 0, // not actuated
	PLUS = 1, // "+" actuated
	MINUS = 2, // "-" actuated
	PLUS_MINUS = 3, // "+" and "-" actuated
	UNKNOWN_1 = 4, // not defined
	UNKNOWN_2 = 5, // not defined
	UNKNOWN_3 = 6, // not defined
	SNV = 7, // signal not available
};

/** Shift-by-Wire control element ID */
enum class SBW_232h_SBWB_ID_EGS52 : uint16_t {
	GWHST_LR = 0, // GWHST_LR valid on bit 0..7 (old signal)
	RES_ALT_FEHLER = 2, // Reserved Old Signal "Error MRSM"
	SBWB_ST_P_RND = 3, // SBWB_ST P, RND valid on bit 0..5 (new signals)
};

/** Shift-by-Wire control P-button */
enum class SBW_232h_SBWB_ST_P_EGS52 : uint16_t {
	IDLE = 0, // P-button in rest position
	P = 1, // P button in "P" position
	INIT = 2, // P button initialization
	SNV = 3, // signal not available
};

/** Shift-by-Wire control Status RND */
enum class SBW_232h_SBWB_ST_RND_EGS52 : uint16_t {
	IDLE = 0, // SBW control in rest position
	R = 1, // SBW control in "R"
	N_OBEN = 2, // SBW control in "N above"
	N_UNTEN = 4, // SBW control in "N below"
	INIT = 6, // SBW control in initialization
	D = 8, // SBW control in "D"
	SNV = 15, // signal not available
};

/** Switching Difference Art */
enum class ART_250h_SLV_ART_EGS52 : uint16_t {
	SKL0 = 0, // Shift characteristic "0"
	SKL1 = 1, // Shift characteristic "1"
	SKL2 = 2, // Shift characteristic "2"
	SKL3 = 3, // Shift characteristic "3"
	SKL4 = 4, // Shift characteristic "4"
	SKL5 = 5, // Shift characteristic "5"
	SKL6 = 6, // Shift characteristic "6"
	SKL7 = 7, // Shift characteristic "7"
	SKL8 = 8, // Shift characteristic "8"
	SKL9 = 9, // Shift characteristic "9"
	SKL10 = 10, // Shift characteristic "10"
};

/** Gear, upper limit */
enum class ART_250h_GMAX_ART_EGS52 : uint16_t {
	PASSIVE = 0, // passive value
	G1 = 1, // Gear, upper limit = 1
	G2 = 2, // Gear, upper limit = 2
	G3 = 3, // Gear, upper limit = 3
	G4 = 4, // Gear, upper limit = 4
	G5 = 5, // Gear, upper limit = 5
	G6 = 6, // Gear, upper limit = 6
	G7 = 7, // Gear, upper limit = 7
};

/** Gear, lower limit */
enum class ART_250h_GMIN_ART_EGS52 : uint16_t {
	PASSIVE = 0, // passive value
	G1 = 1, // Gear, lower limit = 1
	G2 = 2, // Gear, lower limit = 2
	G3 = 3, // Gear, lower limit = 3
	G4 = 4, // Gear, lower limit = 4
	G5 = 5, // Gear, lower limit = 5
	G6 = 6, // Gear, lower limit = 6
	G7 = 7, // Gear, lower limit = 7
};

/** Art error code */
enum class ART_258h_ART_ERR_EGS52 : uint16_t {
	OK = 0, // No error available
	SCHMUTZ = 1, // ART disorder; Sensor dirty
	ART_DEF = 2, // Art defective
	ART_LIM_DEF = 3, // Art / Lim defective
	EXT = 4, // ART; External fault
	DBC_DEF = 5, // DBC defective
	SCHMUTZ_DBC_DEF = 6, // ART disorder; Sensor dirty and DBC defective
	ART_DBC_DEF = 7, // Type and DBC defective
	ART_LIM_DBC_DEF = 8, // Art / Lim and DBC defective
	EXT_DBC = 9, // Art external disorder and DBC defective
	UNKNOWN = 15, // not defined
};

/** Active function */
enum class ART_258h_ASSIST_FKT_AKT_EGS52 : uint16_t {
	AUS = 0, // out
	AAS = 1, // spacer wizard
	ADTR = 2, // Advanced DISTRONIC
	DBC = 3, // Downhill Brake Control
};

/** CAS Display request */
enum class ART_258h_CAS_ERR_ANZ_V2_EGS52 : uint16_t {
	IDLE = 0, // No error
	CAS_SFV_REINIGEN = 1, // CAS Display "Clean bumper front"
	CAS_SFV_SFH_REINIGEN = 2, // CAS Display "Clean bumper front and rear"
	CAS_ERR_W = 3, // CAS Display "Workshop"
};

/** Assistance system Display request */
enum class ART_258h_ASSIST_ANZ_V2_EGS52 : uint16_t {
	IDLE = 0, // basic picture according to active bit
	DBC_LIM = 1, // Message "Turn on DBC / DBC XX km / h"
	DBC_AUS = 2, // Message "Turn off DBC"
	DBC_AUS_TON = 3, // message "Switch off DBC" with sound
	DBC_NV_AKT = 4, // Message "DBC Missing / DBC Not Activable"
	DBC_NV_LIM = 5, // Message "DBC Missing / DBC XX km / h"
	AAS_EIN = 6, // Message "Turn on AAS"
	AAS_AUS = 7, // Message "Turn off AAS"
	AAS_AUS_TON = 8, // Message "Turn off AAS" with sound
	AAS_NV_LIM = 9, // Message "Do not turn on AAS activateable / LIM"
	AAS_NV_OBJ = 10, // Message "AAS not activateable / no destination"
	AAS_NV_FBED = 11, // Message "AAS incorrect operation / not available"
	AAS_FOLGEN = 12, // message "AAS destination goes on / follow"
	AAS_OBJ_VERLUST = 13, // message "AAS object loss"
	AAS_OBJ_WECHSEL = 14, // message "AAS new object / object change"
	PAS_EIN = 15, // message "PAS switch on / PAS active"
	PAS_AUS = 16, // Message "Turn off PAS / PAS"
	PAS_NV = 17, // message "PAS not activatable"
};

/** Current gear distribution gear */
enum class VG_428h_VG_GANG_EGS52 : uint16_t {
	SH_IPG = 0, // Switching is running (Shift in progress)
	LO = 1, // terrain (low range)
	HI = 2, // Road speed (High Range)
	N = 4, // Neutralgang (Not High Or Low Range)
	SNV = 7, // signal not available (signal not available)
};

/** VG request "N" */
enum class VG_428h_ANFN_VG_EGS52 : uint16_t {
	UNKNOWN = 0, // not defined
	ANF_N = 1, // requirement "neutral"
	IDLE = 2, // No requirement
	SNV = 3, // signal not available
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint64_t __PADDING1__: 58;
		/** Frontal event 5 **/
		bool CRASH_C: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING2__: 2;
		/** Frontal event 2 **/
		bool CRASH_F: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		bool __PADDING3__: 1;
		/** Confirm bit for all crazy events, tox **/
		bool CONF_CRASH: 1;
	} __attribute__((packed));
	/** Gets CAN ID of ARCADE_A2_EGS52 **/
	uint32_t get_canid(){ return ARCADE_A2_EGS52_CAN_ID; }
} ARCADE_A2_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint64_t __PADDING1__: 39;
		/** suppress lamp test during stop phase **/
		bool ASS_LTEST_AUS: 1;
		/** Number of ASA status message **/
		MS_ANZ_ASS_DSPL_EGS52 ASS_DSPL: 4;
		/** Number of ASA alert **/
		MS_ANZ_ASS_WARN_EGS52 ASS_WARN: 4;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint16_t __PADDING2__: 16;
	} __attribute__((packed));
	/** Gets CAN ID of MS_ANZ_EGS52 **/
	uint32_t get_canid(){ return MS_ANZ_EGS52_CAN_ID; }
} MS_ANZ_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint64_t __PADDING1__: 44;
		/** Message counter **/
		uint8_t BZ232h: 4;
		/** Shift-by-Wire control Status RND **/
		SBW_232h_SBWB_ST_RND_EGS52 SBWB_ST_RND: 4;
		/** Shift-by-Wire control P-button **/
		SBW_232h_SBWB_ST_P_EGS52 SBWB_ST_P: 2;
		/** Shift-by-Wire control element ID **/
		SBW_232h_SBWB_ID_EGS52 SBWB_ID: 2;
		/** Steering wheel keys "+", "-" actuated **/
		SBW_232h_LRT_PM3_EGS52 LRT_PM3: 3;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING2__: 3;
		/** transmitter recognition **/
		SBW_232h_SID_SBW_EGS52 SID_SBW: 2;
	} __attribute__((packed));
	/** Gets CAN ID of SBW_232_EGS52 **/
	uint32_t get_canid(){ return SBW_232_EGS52_CAN_ID; }
} SBW_232_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING1__: 8;
		/** Gear, lower limit **/
		ART_250h_GMIN_ART_EGS52 GMIN_ART: 3;
		/** Gear, upper limit **/
		ART_250h_GMAX_ART_EGS52 GMAX_ART: 3;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		bool __PADDING2__: 1;
		/** Art desire: "Active recirculation" **/
		bool AKT_R_ART: 1;
		/** brake torque (0000h: passive value) **/
		uint16_t MBRE_ART: 12;
		/** Message counter **/
		uint8_t BZ250h: 4;
		/** Ford. Engine torque **/
		uint16_t M_ART: 13;
		/** Type regulates **/
		bool ART_REG: 1;
		/** Limiter regulates **/
		bool LIM_REG: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING3__: 6;
		/** City Assistant regulates **/
		bool CAS_REG: 1;
		/** Engine torque request dynamic **/
		bool MDYN_ART: 1;
		/** Engine torque Request Parity (just parity) **/
		bool MPAR_ART: 1;
		/** Suppression Dynamic fully detection **/
		bool DYN_UNT: 1;
		/** Brake light suppression **/
		bool BL_UNT: 1;
		/** Type brakes **/
		bool ART_BRE: 1;
		/** Type in order **/
		bool ART_OK: 1;
		/** Switching Difference Art **/
		ART_250h_SLV_ART_EGS52 SLV_ART: 4;
	} __attribute__((packed));
	/** Gets CAN ID of ART_250_EGS52 **/
	uint32_t get_canid(){ return ART_250_EGS52_CAN_ID; }
} ART_250_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** Assistance system Display request **/
		ART_258h_ASSIST_ANZ_V2_EGS52 ASSIST_ANZ_V2: 5;
		/** CAS Display request **/
		ART_258h_CAS_ERR_ANZ_V2_EGS52 CAS_ERR_ANZ_V2: 3;
		/** Active function **/
		ART_258h_ASSIST_FKT_AKT_EGS52 ASSIST_FKT_AKT: 2;
		/** LED spacer wizard flashing **/
		bool AAS_LED_BL: 1;
		/** Object Offer Spacer Wizard **/
		bool OBJ_AGB: 1;
		/** Art distance warning is switched on **/
		bool ART_ABW_AKT: 1;
		/** Display of system availability after system error **/
		bool ART_REAKT: 1;
		/** Type is overplayed by the driver **/
		bool ART_UEBERSP: 1;
		/** Minimum display time in the display new trigger **/
		bool ART_DSPL_NEU: 1;
		/** Speed ​​recognized target vehicle **/
		uint8_t V_ZIEL: 8;
		/** Art Tempomat on **/
		bool TM_EIN_ART: 1;
		/** Fluid indicator flash **/
		bool ART_DSPL_BL: 1;
		/** Turn on style segment display **/
		bool ART_SEG_EIN: 1;
		/** Relevant object recognized **/
		bool OBJ_ERK: 1;
		/** Spacer control mpomat turned on **/
		bool ART_EIN: 1;
		/** Display "---" on the display **/
		bool ART_DSPL_LIM: 1;
		/** Display "DTR OFF [0]" on the display **/
		bool ART_VFBR: 1;
		/** Display "Winter tire limitation achieved" on the display **/
		bool ART_DSPL_PGB: 1;
		/** driver request **/
		uint8_t SOLL_ABST: 8;
		/** distance relevant object **/
		uint8_t ABST_R_OBJ: 8;
		/** set type speed **/
		uint8_t V_ART: 8;
		/** Art error code **/
		ART_258h_ART_ERR_EGS52 ART_ERR: 4;
		/** Art Infolampe **/
		bool ART_INFO: 1;
		/** Art Warning **/
		bool ART_WT: 1;
		/** detection standing object **/
		bool S_OBJ: 1;
		/** Turn the display on type display **/
		bool ART_DSPL_EIN: 1;
	} __attribute__((packed));
	/** Gets CAN ID of ART_258_EGS52 **/
	uint32_t get_canid(){ return ART_258_EGS52_CAN_ID; }
} ART_258_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** Maximum speed **/
		uint16_t PSM_DZ_MAX: 16;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING1__: 5;
		/** Speed limitation active **/
		bool PSM_DZ_AKT: 1;
		/** Speed limitation - Togglebit **/
		bool PSM_DZ_TGL: 1;
		/** Speed limitation - parity bit **/
		bool PSM_DZ_PAR: 1;
		/** Maximum engine torque **/
		uint16_t PSM_MOM_SOLL: 13;
		/** Tomentic limitation active **/
		bool PSM_MOM_AKT: 1;
		/** Tomentic limitation - Togglebit **/
		bool PSM_MOM_TGL: 1;
		/** Tomentic limitation - parity bit **/
		bool PSM_MOM_PAR: 1;
		/** Motoroll speed ADR **/
		uint16_t PSM_N_SOLL: 16;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING2__: 5;
		/** working speed control active **/
		bool PSM_ADR_AKT: 1;
		/** Labor speed control - Togglebit **/
		bool PSM_ADR_TGL: 1;
		/** Work Speed Control - ParityBit **/
		bool PSM_ADR_PAR: 1;
	} __attribute__((packed));
	/** Gets CAN ID of PSM_3B4_EGS52 **/
	uint32_t get_canid(){ return PSM_3B4_EGS52_CAN_ID; }
} PSM_3B4_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint64_t __PADDING1__: 43;
		/** lock accelerator pedal module **/
		bool PSM_FPM_SP: 1;
		/** Motor Remote Stop active **/
		bool PSM_FERN_STOP: 1;
		/** Motor Remote Start active **/
		bool PSM_FERN_START: 1;
		/** Speed limitation - Togglebit **/
		bool PSM_DZ_TGL: 1;
		/** Speed limitation - parity bit **/
		bool PSM_DZ_PAR: 1;
		/** Speed limit **/
		uint8_t PSM_V_SOLL: 8;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING2__: 5;
		/** Speed limitation active **/
		bool PSM_V_AKT: 1;
		/** Speed limitation - Togglebit **/
		bool PSM_V_TGL: 1;
		/** Speed Control - Parity Bit **/
		bool PSM_V_PAR: 1;
	} __attribute__((packed));
	/** Gets CAN ID of PSM_3B8_EGS52 **/
	uint32_t get_canid(){ return PSM_3B8_EGS52_CAN_ID; }
} PSM_3B8_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint64_t __PADDING1__: 48;
		/** VG request "N" **/
		VG_428h_ANFN_VG_EGS52 ANFN_VG: 2;
		/** VG - ANG.Load "N" Toggle 20ms (1 / Embassy) **/
		bool ANFNTGL_VG: 1;
		/** VG - Request "n" Parity (straight parity) **/
		bool ANFNPAR_VG: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING2__: 4;
		/** Current gear distribution gear **/
		VG_428h_VG_GANG_EGS52 VG_GANG: 3;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING3__: 2;
		/** Error VG (ECU Failure Detected) **/
		bool VG_ERR: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING4__: 2;
	} __attribute__((packed));
	/** Gets CAN ID of VG_428_EGS52 **/
	uint32_t get_canid(){ return VG_428_EGS52_CAN_ID; }
} VG_428_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint64_t __PADDING1__: 54;
		/** Substitution low beam right **/
		bool SUB_ABL_R: 1;
		/** Substitution lowlight left **/
		bool SUB_ABL_L: 1;
		/** Display message 1: "Curve light defective! Drive to the workshop" **/
		bool LWR_M1: 1;
		/** Display message 2: "Curve light, replacement light activated!"(White) **/
		bool LWR_M2: 1;
		/** Display message 3: "Curve light currently not available" (white). **/
		bool LWR_M3: 1;
		/** Display message 4: "Curve light currently not available" (white / 5x flashing with 1Hz) **/
		bool LWR_M4: 1;
		/** Display message 5: "Bolt view left" **/
		bool LWR_M5: 1;
		/** Display message 6: "Bolt match right" **/
		bool LWR_M6: 1;
		/** Display message 7: "Baltic view currently not available" **/
		bool LWR_M7: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		bool __PADDING2__: 1;
	} __attribute__((packed));
	/** Gets CAN ID of LWR_530_EGS52 **/
	uint32_t get_canid(){ return LWR_530_EGS52_CAN_ID; }
} LWR_530_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** distribution gear control available **/
		bool VG_VH: 1;
		/** Differential lock in front available **/
		bool DSV_VH: 1;
		/** Differential lock center available **/
		bool DSM_VH: 1;
		/** Differential lock behind available **/
		bool DSH_VH: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint16_t __PADDING1__: 9;
		/** Air conditioning available **/
		bool KLA_VH: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint64_t __PADDING2__: 49;
		/** E-suction fan: basic ventilation **/
		bool GBL_AUS: 1;
	} __attribute__((packed));
	/** Gets CAN ID of CONFIG_6FF_EGS52 **/
	uint32_t get_canid(){ return CONFIG_6FF_EGS52_CAN_ID; }
} CONFIG_6FF_EGS52;



class ECU_ANY_ECU {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint32_t timestamp_now) {
            uint8_t idx = 0;
            bool add = true;
            switch(can_id) {
                case ARCADE_A2_EGS52_CAN_ID:
                    idx = 0;
                    break;
                case MS_ANZ_EGS52_CAN_ID:
                    idx = 1;
                    break;
                case SBW_232_EGS52_CAN_ID:
                    idx = 2;
                    break;
                case ART_250_EGS52_CAN_ID:
                    idx = 3;
                    break;
                case ART_258_EGS52_CAN_ID:
                    idx = 4;
                    break;
                case PSM_3B4_EGS52_CAN_ID:
                    idx = 5;
                    break;
                case PSM_3B8_EGS52_CAN_ID:
                    idx = 6;
                    break;
                case VG_428_EGS52_CAN_ID:
                    idx = 7;
                    break;
                case LWR_530_EGS52_CAN_ID:
                    idx = 8;
                    break;
                case CONFIG_6FF_EGS52_CAN_ID:
                    idx = 9;
                    break;
                default:
                    add = false;
                    break;
            }
            if (add) {
                LAST_FRAME_TIMES[idx] = timestamp_now;
                FRAME_DATA[idx] = value;
            }
            return add;
        }
        
        /** Sets data in pointer to ARCADE_A2
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ARCADE_A2(const uint32_t now, const uint32_t max_expire_time, ARCADE_A2_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[0] <= now && now - LAST_FRAME_TIMES[0] < max_expire_time) {
                dest->raw = FRAME_DATA[0];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to MS_ANZ
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_ANZ(const uint32_t now, const uint32_t max_expire_time, MS_ANZ_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[1] <= now && now - LAST_FRAME_TIMES[1] < max_expire_time) {
                dest->raw = FRAME_DATA[1];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to SBW_232
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SBW_232(const uint32_t now, const uint32_t max_expire_time, SBW_232_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[2] <= now && now - LAST_FRAME_TIMES[2] < max_expire_time) {
                dest->raw = FRAME_DATA[2];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to ART_250
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ART_250(const uint32_t now, const uint32_t max_expire_time, ART_250_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[3] <= now && now - LAST_FRAME_TIMES[3] < max_expire_time) {
                dest->raw = FRAME_DATA[3];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to ART_258
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ART_258(const uint32_t now, const uint32_t max_expire_time, ART_258_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[4] <= now && now - LAST_FRAME_TIMES[4] < max_expire_time) {
                dest->raw = FRAME_DATA[4];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to PSM_3B4
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_PSM_3B4(const uint32_t now, const uint32_t max_expire_time, PSM_3B4_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[5] <= now && now - LAST_FRAME_TIMES[5] < max_expire_time) {
                dest->raw = FRAME_DATA[5];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to PSM_3B8
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_PSM_3B8(const uint32_t now, const uint32_t max_expire_time, PSM_3B8_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[6] <= now && now - LAST_FRAME_TIMES[6] < max_expire_time) {
                dest->raw = FRAME_DATA[6];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to VG_428
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_VG_428(const uint32_t now, const uint32_t max_expire_time, VG_428_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[7] <= now && now - LAST_FRAME_TIMES[7] < max_expire_time) {
                dest->raw = FRAME_DATA[7];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to LWR_530
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_LWR_530(const uint32_t now, const uint32_t max_expire_time, LWR_530_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[8] <= now && now - LAST_FRAME_TIMES[8] < max_expire_time) {
                dest->raw = FRAME_DATA[8];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to CONFIG_6FF
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_CONFIG_6FF(const uint32_t now, const uint32_t max_expire_time, CONFIG_6FF_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[9] <= now && now - LAST_FRAME_TIMES[9] < max_expire_time) {
                dest->raw = FRAME_DATA[9];
                ret = true;
            }
            return ret;
        }
            
	private:
		uint64_t FRAME_DATA[10];
		uint32_t LAST_FRAME_TIMES[10];
};
#endif // __ECU_ANY_ECU_H_