
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'MS51'
*/

#ifndef __ECU_MS51_H_
#define __ECU_MS51_H_

#include <stdint.h>
    
#define MS_308_EGS51_CAN_ID 0x0308
#define MS_210_EGS51_CAN_ID 0x0210
#define MS_310_EGS51_CAN_ID 0x0310
#define MS_608_EGS51_CAN_ID 0x0608

/** switching line shift MS */
enum class MS_210h_SLV_MS_EGS51 : uint16_t {
	SKL0 = 0, // Shift characteristic "0"
	SKL1 = 1, // Shift characteristic "1"
	SKL2 = 2, // Shift characteristic "2"
	SKL3 = 3, // Shift characteristic "3"
	SKL4 = 4, // Shift characteristic "4"
	SKL5 = 5, // Shift characteristic "5"
	SKL6 = 6, // Shift characteristic "6"
	SKL7 = 7, // Shift characteristic "7"
	SKL8 = 8, // Shift characteristic "8"
	SKL9 = 9, // Shift characteristic "9"
	SKL10 = 10, // Shift characteristic "10"
};

/** Gear, upper limit */
enum class MS_210h_GMAX_MS_EGS51 : uint16_t {
	PASSIVE = 0, // passive value
	G1 = 1, // Gear, upper limit = 1
	G2 = 2, // Gear, upper limit = 2
	G3 = 3, // Gear, upper limit = 3
	G4 = 4, // Gear, upper limit = 4
	G5 = 5, // Gear, upper limit = 5
	G6 = 6, // Gear, upper limit = 6
	G7 = 7, // Gear, upper limit = 7
};

/** Gear, lower limit */
enum class MS_210h_GMIN_MS_EGS51 : uint16_t {
	PASSIVE = 0, // passive value
	G1 = 1, // Gear, lower limit = 1
	G2 = 2, // Gear, lower limit = 2
	G3 = 3, // Gear, lower limit = 3
	G4 = 4, // Gear, lower limit = 4
	G5 = 5, // Gear, lower limit = 5
	G6 = 6, // Gear, lower limit = 6
	G7 = 7, // Gear, lower limit = 7
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** oil quality **/
		uint8_t OEL_QUAL: 8;
		/** oil level **/
		uint8_t OEL_FS: 8;
		/** Oil temperature **/
		uint8_t T_OEL: 8;
		/** cooling water temperature too high **/
		bool TEMP_KL: 1;
		/** Speed limitation for display active (0 at CR) **/
		bool DBAA: 1;
		/** Motor Heater Defective Control Lamp **/
		bool LUEFT_MOT_KL: 1;
		/** starter is running **/
		bool ANL_LFT: 1;
		/** ADR defective control lamp (NFZ only) **/
		bool ADR_DEF_KL: 1;
		/** ADR check lamp (NFZ only) **/
		bool ADR_KL: 1;
		/** Cylinder shutdown **/
		bool ZAS: 1;
		/** Engine oil temperature too high (overheating) **/
		bool UEHITZ: 1;
		/** Tank lid open check lamp **/
		bool TANK_KL: 1;
		/** Diagnosis Control Lamp (OBD II) **/
		bool DIAG_KL: 1;
		/** oil level / oil pressure control lamp **/
		bool OEL_KL: 1;
		/** pre-glow control lamp **/
		bool VGL_KL: 1;
		/** Air filter dirty warning lamp (only diesel) **/
		bool LUFI_KL: 1;
		/** Ethanol operation detected **/
		bool EOH: 1;
		/** Warning message ECO steering helping pump **/
		bool ELHP_WARN: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		bool __PADDING1__: 1;
		/** engine speed **/
		uint16_t NMOT: 16;
		/** Cylinder shutdown conditions fulfilled **/
		bool ZASBED: 1;
		/** Water in the fuel control lamp (CR2 US only) **/
		bool WKS_KL: 1;
		/** Fuel filter clogs control lamp (CR2 US only) **/
		bool KSF_KL: 1;
		/** push shutdown full **/
		bool SASV: 1;
		/** Partinal shutdown **/
		bool SAST: 1;
		/** Speed limiting function active **/
		bool N_MAX_BG: 1;
		/** start.Convertible bridging clutch "Open" **/
		bool KUEB_O_A: 1;
		/** clutch kicked **/
		bool KPL: 1;
	} __attribute__((packed));
	/** Gets CAN ID of MS_308_EGS51 **/
	uint32_t get_canid(){ return MS_308_EGS51_CAN_ID; }
} MS_308_EGS51;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** Set maximum or cruise control speed **/
		uint8_t V_MAX_TM: 8;
		/** factor for fill value. d. max. Mom with remo.. A.druck **/
		uint8_t FMMOTMAX: 8;
		/** Geschw.begrenzer- / cruise control display a **/
		bool V_DSPL_EIN: 1;
		/** display flashes **/
		bool V_DSPL_BL: 1;
		/** "Error" indicator on the display **/
		bool V_DSPL_ERR: 1;
		/** Display "limit?" on display **/
		bool V_DSPL_LIM: 1;
		/** Speed ​​controls **/
		bool V_MAX_REG: 1;
		/** activated cruise control **/
		bool TM_EIN: 1;
		/** "achieved winter tires limitation" Indicated on display **/
		bool V_DSPL_PGB: 1;
		/** FBStart Error **/
		bool FBS_SE: 1;
		/** Warning buzzer **/
		bool V_MAX_SUM: 1;
		/** emergency operation **/
		bool NOTL: 1;
		/** Kick Down (changeover scenario open!) **/
		bool KD_MS: 1;
		/** activated speed limit **/
		bool V_MAX_EIN: 1;
		/** cruise control regulates **/
		bool TM_REG: 1;
		/** beg. "Slip" lock-up clutch **/
		bool KUEB_S_A: 1;
		/** idle **/
		bool LL: 1;
		/** error pedal sensor **/
		bool PWG_ERR: 1;
		/** Crash signal from motor control **/
		bool CRASH_MS: 1;
		/** turn air compressor:: S acceleration **/
		bool KOMP_BAUS: 1;
		/** engine start / stop system active **/
		bool MSS_AKT: 1;
		/** engine start / stop system warning **/
		bool MSS_KL: 1;
		/** Engine Start / Stop system is defective **/
		bool MSS_DEF: 1;
		/** Vorglühstatus **/
		bool VGL_ST: 1;
		/** idle is stable **/
		bool LL_STBL: 1;
		/** retrigger minimum display time in the display: S **/
		bool V_DSPL_NEU: 1;
		/** pedal **/
		uint8_t PW: 8;
		/** Gear, lower limit **/
		MS_210h_GMIN_MS_EGS51 GMIN_MS: 3;
		/** Gear, upper limit **/
		MS_210h_GMAX_MS_EGS51 GMAX_MS: 3;
		/** Turn off heater **/
		bool ZH_AUS_MS: 1;
		/** MS-wish: "Active downshift" **/
		bool AKT_R_MS: 1;
		/** MS-wish: "Approach 1.Gang" **/
		bool ANF1: 1;
		/** Switch KSG-creep **/
		bool KRIECH_AUS: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		bool __PADDING1__: 1;
		/** switching line shift MS **/
		MS_210h_SLV_MS_EGS51 SLV_MS: 4;
		/** Air compressor Emergency Shutdown **/
		bool KOMP_NOTAUS: 1;
	} __attribute__((packed));
	/** Gets CAN ID of MS_210_EGS51 **/
	uint32_t get_canid(){ return MS_210_EGS51_CAN_ID; }
} MS_210_EGS51;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** engine drag torque **/
		uint8_t MIN_TORQUE: 8;
		/** engine drag torque **/
		uint8_t MAX_TORQUE: 8;
		/** engine drag torque **/
		uint8_t STA_TORQUE: 8;
		/** engine indicated torque **/
		uint8_t IND_TORQUE: 8;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint32_t __PADDING1__: 32;
	} __attribute__((packed));
	/** Gets CAN ID of MS_310_EGS51 **/
	uint32_t get_canid(){ return MS_310_EGS51_CAN_ID; }
} MS_310_EGS51;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING1__: 8;
		/** consumption **/
		uint16_t VB: 16;
		/** Fixed maximum speed **/
		uint8_t V_MAX_FIX: 8;
		/** FZGCOD.Motor 7Bit, bit0-5 (bit6 -> signal fcod_mot6) **/
		uint8_t FCOD_MOT: 6;
		/** Transmission control not available **/
		bool GS_NVH: 1;
		/** Vehicle code engine with 7 bit, bit 6 **/
		bool FCOD_MOT6: 1;
		/** Vehicle code series **/
		uint8_t FCOD_BR: 5;
		/** Vehicle code body **/
		uint8_t FCOD_KAR: 3;
		/** intake air temperature **/
		uint8_t T_LUFT: 8;
		/** engine coolant temperature **/
		uint8_t T_MOT: 8;
	} __attribute__((packed));
	/** Gets CAN ID of MS_608_EGS51 **/
	uint32_t get_canid(){ return MS_608_EGS51_CAN_ID; }
} MS_608_EGS51;



class ECU_MS51 {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            uint8_t idx = 0;
            bool add = true;
            switch(can_id) {
                case MS_308_EGS51_CAN_ID:
                    idx = 0;
                    break;
                case MS_210_EGS51_CAN_ID:
                    idx = 1;
                    break;
                case MS_310_EGS51_CAN_ID:
                    idx = 2;
                    break;
                case MS_608_EGS51_CAN_ID:
                    idx = 3;
                    break;
                default:
                    add = false;
                    break;
            }
            if (add) {
                LAST_FRAME_TIMES[idx] = timestamp_now;
                FRAME_DATA[idx] = value;
            }
            return add;
        }
        
        /** Sets data in pointer to MS_308
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_308(uint64_t now, uint64_t max_expire_time, MS_308_EGS51* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[0] <= now && now - LAST_FRAME_TIMES[0] < max_expire_time) {
                dest->raw = FRAME_DATA[0];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to MS_210
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_210(uint64_t now, uint64_t max_expire_time, MS_210_EGS51* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[1] <= now && now - LAST_FRAME_TIMES[1] < max_expire_time) {
                dest->raw = FRAME_DATA[1];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to MS_310
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_310(uint64_t now, uint64_t max_expire_time, MS_310_EGS51* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[2] <= now && now - LAST_FRAME_TIMES[2] < max_expire_time) {
                dest->raw = FRAME_DATA[2];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to MS_608
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_608(uint64_t now, uint64_t max_expire_time, MS_608_EGS51* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[3] <= now && now - LAST_FRAME_TIMES[3] < max_expire_time) {
                dest->raw = FRAME_DATA[3];
                ret = true;
            }
            return ret;
        }
            
	private:
		uint64_t FRAME_DATA[4];
		uint64_t LAST_FRAME_TIMES[4];
};
#endif // __ECU_MS51_H_