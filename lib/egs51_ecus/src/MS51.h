
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'MS51'
*/

#ifndef __ECU_MS51_H_
#define __ECU_MS51_H_

#include <stdint.h>
    
#define MS_308_EGS51_CAN_ID 0x0308
#define MS_210_EGS51_CAN_ID 0x0210
#define MS_310_EGS51_CAN_ID 0x0310
#define MS_608_EGS51_CAN_ID 0x0608



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** oil quality **/
		uint8_t OEL_QUAL: 8;
		/** oil level **/
		uint8_t OEL_FS: 8;
		/** Oil temperature **/
		uint8_t T_OEL: 8;
		/** cooling water temperature too high **/
		bool TEMP_KL: 1;
		/** Speed limitation for display active (0 at CR) **/
		bool DBAA: 1;
		/** Motor Heater Defective Control Lamp **/
		bool LUEFT_MOT_KL: 1;
		/** starter is running **/
		bool ANL_LFT: 1;
		/** ADR defective control lamp (NFZ only) **/
		bool ADR_DEF_KL: 1;
		/** ADR check lamp (NFZ only) **/
		bool ADR_KL: 1;
		/** Cylinder shutdown **/
		bool ZAS: 1;
		/** Engine oil temperature too high (overheating) **/
		bool UEHITZ: 1;
		/** Tank lid open check lamp **/
		bool TANK_KL: 1;
		/** Diagnosis Control Lamp (OBD II) **/
		bool DIAG_KL: 1;
		/** oil level / oil pressure control lamp **/
		bool OEL_KL: 1;
		/** pre-glow control lamp **/
		bool VGL_KL: 1;
		/** Air filter dirty warning lamp (only diesel) **/
		bool LUFI_KL: 1;
		/** Ethanol operation detected **/
		bool EOH: 1;
		/** Warning message ECO steering helping pump **/
		bool ELHP_WARN: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		bool __PADDING1__: 1;
		/** engine speed **/
		uint16_t NMOT: 16;
		/** Cylinder shutdown conditions fulfilled **/
		bool ZASBED: 1;
		/** Water in the fuel control lamp (CR2 US only) **/
		bool WKS_KL: 1;
		/** Fuel filter clogs control lamp (CR2 US only) **/
		bool KSF_KL: 1;
		/** push shutdown full **/
		bool SASV: 1;
		/** Partinal shutdown **/
		bool SAST: 1;
		/** Speed limiting function active **/
		bool N_MAX_BG: 1;
		/** start.Convertible bridging clutch "Open" **/
		bool KUEB_O_A: 1;
		/** clutch kicked **/
		bool KPL: 1;
	} __attribute__((packed));
	/** Gets CAN ID of MS_308_EGS51 **/
	uint32_t get_canid(){ return MS_308_EGS51_CAN_ID; }
} MS_308_EGS51;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING1__: 8;
		/** Motor torque for ESP **/
		uint8_t M_ESP: 8;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint32_t __PADDING2__: 24;
		/** Pedal position **/
		uint8_t PW: 8;
		/** Ignition angle **/
		uint8_t IGN_ANG: 8;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING3__: 8;
	} __attribute__((packed));
	/** Gets CAN ID of MS_210_EGS51 **/
	uint32_t get_canid(){ return MS_210_EGS51_CAN_ID; }
} MS_210_EGS51;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** engine min torque **/
		uint8_t MIN_TORQUE: 8;
		/** engine max torque **/
		uint8_t MAX_TORQUE: 8;
		/** engine drag torque **/
		uint8_t DRG_TORQUE: 8;
		/** engine indicated torque **/
		uint8_t IND_TORQUE: 8;
		/** factor of max torque **/
		uint8_t MAX_TRQ_FACTOR: 8;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint32_t __PADDING1__: 24;
	} __attribute__((packed));
	/** Gets CAN ID of MS_310_EGS51 **/
	uint32_t get_canid(){ return MS_310_EGS51_CAN_ID; }
} MS_310_EGS51;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING1__: 8;
		/** consumption **/
		uint16_t VB: 16;
		/** Fixed maximum speed **/
		uint8_t V_MAX_FIX: 8;
		/** FZGCOD.Motor 7Bit, bit0-5 (bit6 -> signal fcod_mot6) **/
		uint8_t FCOD_MOT: 6;
		/** Transmission control not available **/
		bool GS_NVH: 1;
		/** Vehicle code engine with 7 bit, bit 6 **/
		bool FCOD_MOT6: 1;
		/** Vehicle code series **/
		uint8_t FCOD_BR: 5;
		/** Vehicle code body **/
		uint8_t FCOD_KAR: 3;
		/** intake air temperature **/
		uint8_t T_LUFT: 8;
		/** engine coolant temperature **/
		uint8_t T_MOT: 8;
	} __attribute__((packed));
	/** Gets CAN ID of MS_608_EGS51 **/
	uint32_t get_canid(){ return MS_608_EGS51_CAN_ID; }
} MS_608_EGS51;



class ECU_MS51 {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint32_t timestamp_now) {
            uint8_t idx = 0;
            bool add = true;
            switch(can_id) {
                case MS_308_EGS51_CAN_ID:
                    idx = 0;
                    break;
                case MS_210_EGS51_CAN_ID:
                    idx = 1;
                    break;
                case MS_310_EGS51_CAN_ID:
                    idx = 2;
                    break;
                case MS_608_EGS51_CAN_ID:
                    idx = 3;
                    break;
                default:
                    add = false;
                    break;
            }
            if (add) {
                LAST_FRAME_TIMES[idx] = timestamp_now;
                FRAME_DATA[idx] = value;
            }
            return add;
        }
        
        /** Sets data in pointer to MS_308
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_308(const uint32_t now, const uint32_t max_expire_time, MS_308_EGS51* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[0] <= now && now - LAST_FRAME_TIMES[0] < max_expire_time) {
                dest->raw = FRAME_DATA[0];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to MS_210
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_210(const uint32_t now, const uint32_t max_expire_time, MS_210_EGS51* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[1] <= now && now - LAST_FRAME_TIMES[1] < max_expire_time) {
                dest->raw = FRAME_DATA[1];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to MS_310
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_310(const uint32_t now, const uint32_t max_expire_time, MS_310_EGS51* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[2] <= now && now - LAST_FRAME_TIMES[2] < max_expire_time) {
                dest->raw = FRAME_DATA[2];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to MS_608
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_608(const uint32_t now, const uint32_t max_expire_time, MS_608_EGS51* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[3] <= now && now - LAST_FRAME_TIMES[3] < max_expire_time) {
                dest->raw = FRAME_DATA[3];
                ret = true;
            }
            return ret;
        }
            
	private:
		uint64_t FRAME_DATA[4];
		uint32_t LAST_FRAME_TIMES[4];
};
#endif // __ECU_MS51_H_