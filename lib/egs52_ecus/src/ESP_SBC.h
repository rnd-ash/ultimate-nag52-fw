
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'ESP_SBC'
*/

#ifndef __ECU_ESP_SBC_H_
#define __ECU_ESP_SBC_H_

#include <stdint.h>
    
#define BS_200_EGS52_CAN_ID 0x0200
#define BS_208_EGS52_CAN_ID 0x0208
#define BS_270_EGS52_CAN_ID 0x0270
#define BS_300_EGS52_CAN_ID 0x0300
#define BS_328_EGS52_CAN_ID 0x0328

/** brake light switch */
enum class BS_200h_BLS_EGS52 : uint16_t {
	BREMSE_NBET = 0, // Brake not actuated
	BREMSE_BET = 1, // brake actuated
	UNKNOWN = 2, // not defined
	SNV = 3, // signal not available
};

/** rotary direction wheel front left */
enum class BS_200h_DRTGVL_EGS52 : uint16_t {
	PASSIVE = 0, // No rotation detection
	FWD = 1, // direction of rotation forward
	REV = 2, // direction of rotation backwards
	SNV = 3, // signal not available
};

/** direction of rotation wheel front right */
enum class BS_200h_DRTGVR_EGS52 : uint16_t {
	PASSIVE = 0, // No rotation detection
	FWD = 1, // direction of rotation forward
	REV = 2, // direction of rotation backwards
	SNV = 3, // signal not available
};

/** Rad Left for Cruise */
enum class BS_200h_DRTGTM_EGS52 : uint16_t {
	PASSIVE = 0, // No rotation detection
	FWD = 1, // direction of rotation forward
	REV = 2, // direction of rotation backwards
	SNV = 3, // signal not available
};

/** Gear, upper limit */
enum class BS_208h_GMAX_ESP_EGS52 : uint16_t {
	PASSIVE = 0, // passive value
	G1 = 1, // Gear, upper limit = 1
	G2 = 2, // Gear, upper limit = 2
	G3 = 3, // Gear, upper limit = 3
	G4 = 4, // Gear, upper limit = 4
	G5 = 5, // Gear, upper limit = 5
	G6 = 6, // Gear, upper limit = 6
	G7 = 7, // Gear, upper limit = 7
};

/** Gear, lower limit */
enum class BS_208h_GMIN_ESP_EGS52 : uint16_t {
	PASSIVE = 0, // passive value
	G1 = 1, // Gear, lower limit = 1
	G2 = 2, // Gear, lower limit = 2
	G3 = 3, // Gear, lower limit = 3
	G4 = 4, // Gear, lower limit = 4
	G5 = 5, // Gear, lower limit = 5
	G6 = 6, // Gear, lower limit = 6
	G7 = 7, // Gear, lower limit = 7
};

/** system condition */
enum class BS_208h_SZS_EGS52 : uint16_t {
	ERR = 0, // system error
	NORM = 1, // normal operation
	DIAG = 2, // Diagnosis
	ABGAS = 3, // exhaust gas test
};

/** Switching Difference ESP */
enum class BS_208h_SLV_ESP_EGS52 : uint16_t {
	SKL0 = 0, // Shift characteristic "0"
	SKL1 = 1, // Shift characteristic "1"
	SKL2 = 2, // Shift characteristic "2"
	SKL3 = 3, // Shift characteristic "3"
	SKL4 = 4, // Shift characteristic "4"
	SKL5 = 5, // Shift characteristic "5"
	SKL6 = 6, // Shift characteristic "6"
	SKL7 = 7, // Shift characteristic "7"
	SKL8 = 8, // Shift characteristic "8"
	SKL9 = 9, // Shift characteristic "9"
	SKL10 = 10, // Shift characteristic "10"
};

/** ESP request: "N" Insert */
enum class BS_208h_ANFN_EGS52 : uint16_t {
	UNKNOWN = 0, // not defined
	ANF_N = 1, // requirement "neutral"
	IDLE = 2, // No requirement
	SNV = 3, // signal not available
};

/** rotary direction wheel rear right */
enum class BS_208h_DRTGHR_EGS52 : uint16_t {
	PASSIVE = 0, // No rotation detection
	FWD = 1, // direction of rotation forward
	REV = 2, // direction of rotation backwards
	SNV = 3, // signal not available
};

/** rotary direction wheel rear left */
enum class BS_208h_DRTGHL_EGS52 : uint16_t {
	PASSIVE = 0, // No rotation detection
	FWD = 1, // direction of rotation forward
	REV = 2, // direction of rotation backwards
	SNV = 3, // signal not available
};

/** Alerts PlatRollwarner */
enum class BS_270h_PRW_WARN_EGS52 : uint16_t {
	OK = 0, // No warning
	WARN_OHNE = 1, // Tire pressure warning without position specification
	PRW_NV = 2, // PRW not available
	PRW_START = 3, // Restart PRW
	WARN_VL = 4, // Tire pressure warning front left
	WARN_VR = 5, // Tire pressure warning front right
	WARN_HL = 6, // Tire pressure warning rear left
	WARN_HR = 7, // Tire pressure warning rear right
	UNKNOWN_1 = 8, // not defined
	UNKNOWN_2 = 14, // not defined
	SNV = 15, // signal not available
};

/** Status flat tyre warner */
enum class BS_270h_PRW_ST_EGS52 : uint16_t {
	EIN = 0, // PRW active, no warning
	WARN = 1, // PRW active, warning is available
	AUS = 2, // PRW inactive or not available
	INIT = 3, // PRW is initialized
	UNKNOWN_1 = 4, // not defined
	UNKNOWN_2 = 5, // not defined
	PRW_NV = 6, // PRW not available
	SNV = 7, // signal not available
};

/** Send cycle time */
enum class BS_300h_T_Z_EGS52 : uint16_t {
	UNKNOWN = 0, // not defined
	T20_0 = 1, // send cycle time 20 ms
	T23_1 = 2, // send cycle time 23.1 ms
	SNV = 3, // signal not available
};

/** driver brakes */
enum class BS_300h_SFB_EGS52 : uint16_t {
	BREMSE_NEIN = 0, // driver does not slower
	BREMSE_JA = 1, // driver brakes
	UNKNOWN = 2, // not defined
	SNV = 3, // signal not available
};

/** ESP display messages */
enum class BS_328h_ESP_DSPL_EGS52 : uint16_t {
	OK = 0, // No error
	ESP_DEF = 1, // ESP defective
	ESP_OFF = 2, // ESP not available
	ESP_OFF_DS = 3, // ESP not available, DifferentialSp. active (only 463/461)
	BAS_DEF = 4, // Bas defective
	ABS_DEF = 5, // ABS defective (only 463/461)
	ABS_OFF = 6, // ABS Not available (463/461 only)
	BKV_DEF_GBV = 7, // BKV defective (463/461 only)
	ALL_OFF_DS = 8, // ABS, BAS u. ESP Not available (463/461 only)
	SBCS_DEF = 9, // Stop & Roll defective
	SBCS_ON = 10, // Stop & Roll
	SBCH_N_AKT = 11, // SBC HOLD not activatable
	ESP_BAS_DEF = 13, // BAS u. ESP defective
	SBCH_OFF = 14, // SBC HOLD OFF
	SBCH = 15, // SBC HOLD
	ALL_DEF = 16, // ABS, BAS u. ESP defective
	ALL_DEF_GBV = 17, // ABS, BAS, ESP u. BKV defective
	ALL_DIAG = 19, // ABS, BAS u. ESP DIAG. Test.
	ALL_DIAG_GBV = 20, // ABS, BAS, ESP u. BKV DIAG. Test
	ALL_OFF = 22, // ABS, BAS u. ESP not available
	ALL_OFF_GBV = 23, // ABS, BAS, ESP u. BKV not available
	SBCS = 24, // SBC stop
	SBCS_OFF = 25, // SBC stop out
	BRAKE = 26, // Brake immediately!
	SBCS_N_AKT = 27, // SBC stop not activatable
	SBCH_DEF = 28, // SBC HOLD defective
	SBCS_DEF2 = 29, // SBC Stop defective
	GWH_P = 30, // selector lever according to P
	SNV = 31, // signal not available
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** wheel speed links for cruise control **/
		uint16_t TM_DL: 14;
		/** Rad Left for Cruise **/
		BS_200h_DRTGTM_EGS52 DRTGTM: 2;
		/** Right speed front right **/
		uint16_t DVR: 14;
		/** direction of rotation wheel front right **/
		BS_200h_DRTGVR_EGS52 DRTGVR: 2;
		/** wheel speed front left **/
		uint16_t DVL: 14;
		/** rotary direction wheel front left **/
		BS_200h_DRTGVL_EGS52 DRTGVL: 2;
		/** brake light switch **/
		BS_200h_BLS_EGS52 BLS: 2;
		/** Message counter **/
		uint8_t BZ200h: 4;
		/** BLS Parity (straight parity) **/
		bool BLS_PA: 1;
		/** Brake light suppression (EBV_KL at 163 / T0 / T1N) **/
		bool BLS_UNT: 1;
		/** brake pad wear control lamp **/
		bool BBV_KL: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		bool __PADDING1__: 1;
		/** ABS defective control lamp **/
		bool ABS_KL: 1;
		/** ESP defective control lamp **/
		bool ESP_KL: 1;
		/** ESP Info lamp permanent light **/
		bool ESP_INFO_DL: 1;
		/** ESP Infolramp flashing light **/
		bool ESP_INFO_BL: 1;
		/** Bas defective control lamp **/
		bool BAS_KL: 1;
		/** Brake defective control lamp (EBV_KL at 463/461 / NCV2) **/
		bool BRE_KL: 1;
	} __attribute__((packed));
	/** Gets CAN ID of BS_200_EGS52 **/
	uint32_t get_canid(){ return BS_200_EGS52_CAN_ID; }
} BS_200_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** Rear wheel speed **/
		uint16_t DHL: 14;
		/** rotary direction wheel rear left **/
		BS_208h_DRTGHL_EGS52 DRTGHL: 2;
		/** Rear wheel speed **/
		uint16_t DHR: 14;
		/** rotary direction wheel rear right **/
		BS_208h_DRTGHR_EGS52 DRTGHR: 2;
		/** set braking torque (BR240 factor 1.8 larger) **/
		uint16_t MBRE_ESP: 12;
		/** ART brake intervention active **/
		bool BRE_AKT_ART: 1;
		/** ESP request: "N" Insert **/
		BS_208h_ANFN_EGS52 ANFN: 2;
		/** ESP brake engagement active **/
		bool BRE_AKT_ESP: 1;
		/** Switching Difference ESP **/
		BS_208h_SLV_ESP_EGS52 SLV_ESP: 4;
		/** Tempomat operation **/
		bool TM_AUS: 1;
		/** system condition **/
		BS_208h_SZS_EGS52 SZS: 2;
		/** Suppression Dynamic fully detection **/
		bool DDYN_UNT: 1;
		/** Gear, lower limit **/
		BS_208h_GMIN_ESP_EGS52 GMIN_ESP: 3;
		/** Gear, upper limit **/
		BS_208h_GMAX_ESP_EGS52 GMAX_ESP: 3;
		/** Gear requirement of art **/
		bool MINMAX_ART: 1;
		/** ESP / Art-Wish: "Active Retract" **/
		bool AKT_R_ESP: 1;
	} __attribute__((packed));
	/** Gets CAN ID of BS_208_EGS52 **/
	uint32_t get_canid(){ return BS_208_EGS52_CAN_ID; }
} BS_208_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint64_t __PADDING1__: 40;
		/** Status flat tyre warner **/
		BS_270h_PRW_ST_EGS52 PRW_ST: 3;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		bool __PADDING2__: 1;
		/** Alerts PlatRollwarner **/
		BS_270h_PRW_WARN_EGS52 PRW_WARN: 4;
		/** Impulse ring counter wheel rear right (48 per revolution) **/
		uint8_t RIZ_HR: 8;
		/** Impulse ring counter wheel rear left (48 per revolution) **/
		uint8_t RIZ_HL: 8;
	} __attribute__((packed));
	/** Gets CAN ID of BS_270_EGS52 **/
	uint32_t get_canid(){ return BS_270_EGS52_CAN_ID; }
} BS_270_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** raw signal yaw rate without reconciliation / filtering (+ = left) **/
		uint16_t GIER_ROH: 16;
		/** Ford.Engine torque **/
		uint16_t M_ESP: 13;
		/** Engine torque request max **/
		bool MMAX_ESP: 1;
		/** Engine torque request min **/
		bool MMIN_ESP: 1;
		/** Motor torque toggle 40ms + -10 **/
		bool MTGL_ESP: 1;
		/** Ford.Engine torque **/
		uint16_t DM_ART: 13;
		/** Engine torque request max **/
		bool DMMAX_ART: 1;
		/** Engine torque request min **/
		bool DMMIN_ART: 1;
		/** Motor torque toggle 40ms + -10 **/
		bool DMTGL_ART: 1;
		/** driver brakes **/
		BS_300h_SFB_EGS52 SFB: 2;
		/** driver brakes parity (straight parity) **/
		bool SFB_PA: 1;
		/** Send cycle time **/
		BS_300h_T_Z_EGS52 T_Z: 2;
		/** drive torque control active **/
		bool AMR_AKT_ESP: 1;
		/** Engine torque request dynamic **/
		bool MDYN_ESP: 1;
		/** Engine torque Request Parity (just parity) **/
		bool MPAR_ESP: 1;
		/** Initialization steering angle sensor possible **/
		bool LWS_INI_EIN: 1;
		/** Initialization Steering Angle Sensor O.K. **/
		bool LWS_INI_OK: 1;
		/** ESP giermom control active **/
		bool ESP_GIER_AKT: 1;
		/** Enable Art **/
		bool ART_E: 1;
		/** full braking (ABS regulates all 4 wheels) **/
		bool VOLLBRE: 1;
		/** Bas-control active **/
		bool BAS_AKT: 1;
		/** Engine torque request dynamic **/
		bool DMDYN_ART: 1;
		/** Engine torque Request Parity (just parity) **/
		bool DMPAR_ART: 1;
	} __attribute__((packed));
	/** Gets CAN ID of BS_300_EGS52 **/
	uint32_t get_canid(){ return BS_300_EGS52_CAN_ID; }
} BS_300_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** Impulse ring counter wheel front right (48 per revolution) **/
		uint8_t RIZ_VR: 8;
		/** Impulse ring counter wheel front left (48 per revolution) **/
		uint8_t RIZ_VL: 8;
		/** Message counter **/
		uint8_t BZ328h: 3;
		/** Open clutch **/
		bool KPL_OEF: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING1__: 2;
		/** Emergency braking (brake light blink) **/
		bool NOTBRE: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		bool __PADDING2__: 1;
		/** ESP display messages **/
		BS_328h_ESP_DSPL_EGS52 ESP_DSPL: 5;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint16_t __PADDING3__: 11;
		/** Vehicle lateral acceleration. The focus (+ = left) **/
		uint8_t AY_S: 8;
		/** target wobble moment change **/
		uint16_t WMS: 15;
		/** WMS Parity (straight parity) **/
		bool WMS_PA: 1;
	} __attribute__((packed));
	/** Gets CAN ID of BS_328_EGS52 **/
	uint32_t get_canid(){ return BS_328_EGS52_CAN_ID; }
} BS_328_EGS52;



class ECU_ESP_SBC {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            uint8_t idx = 0;
            bool add = true;
            switch(can_id) {
                case BS_200_EGS52_CAN_ID:
                    idx = 0;
                    break;
                case BS_208_EGS52_CAN_ID:
                    idx = 1;
                    break;
                case BS_270_EGS52_CAN_ID:
                    idx = 2;
                    break;
                case BS_300_EGS52_CAN_ID:
                    idx = 3;
                    break;
                case BS_328_EGS52_CAN_ID:
                    idx = 4;
                    break;
                default:
                    add = false;
                    break;
            }
            if (add) {
                LAST_FRAME_TIMES[idx] = timestamp_now;
                FRAME_DATA[idx] = value;
            }
            return add;
        }
        
        /** Sets data in pointer to BS_200
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_200(uint64_t now, uint64_t max_expire_time, BS_200_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[0] <= now && now - LAST_FRAME_TIMES[0] < max_expire_time) {
                dest->raw = FRAME_DATA[0];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to BS_208
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_208(uint64_t now, uint64_t max_expire_time, BS_208_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[1] <= now && now - LAST_FRAME_TIMES[1] < max_expire_time) {
                dest->raw = FRAME_DATA[1];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to BS_270
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_270(uint64_t now, uint64_t max_expire_time, BS_270_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[2] <= now && now - LAST_FRAME_TIMES[2] < max_expire_time) {
                dest->raw = FRAME_DATA[2];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to BS_300
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_300(uint64_t now, uint64_t max_expire_time, BS_300_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[3] <= now && now - LAST_FRAME_TIMES[3] < max_expire_time) {
                dest->raw = FRAME_DATA[3];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to BS_328
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_328(uint64_t now, uint64_t max_expire_time, BS_328_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[4] <= now && now - LAST_FRAME_TIMES[4] < max_expire_time) {
                dest->raw = FRAME_DATA[4];
                ret = true;
            }
            return ret;
        }
            
	private:
		uint64_t FRAME_DATA[5];
		uint64_t LAST_FRAME_TIMES[5];
};
#endif // __ECU_ESP_SBC_H_