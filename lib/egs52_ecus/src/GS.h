
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'GS'
*/

#ifndef __ECU_GS_H_
#define __ECU_GS_H_

#include <stdint.h>
    
#define GS_218_EGS52_CAN_ID 0x0218
#define GS_338_EGS52_CAN_ID 0x0338
#define GS_418_EGS52_CAN_ID 0x0418

/** Goal Gang */
enum class GS_218h_GZC_EGS52 : uint16_t {
	G_N = 0, // Destination "N"
	G_D1 = 1, // Destination "1"
	G_D2 = 2, // Destination "2"
	G_D3 = 3, // Destination "3"
	G_D4 = 4, // Destination "4"
	G_D5 = 5, // Destination "5"
	G_D6 = 6, // Destination "6"
	G_D7 = 7, // Destination "7"
	G_D_CVT = 8, // Destination "infinitely forward
	G_R_CVT = 9, // Goal "infinitely reverse"
	G_R3 = 10, // Destination "R3"
	G_R = 11, // Destination "R"
	G_R2 = 12, // Destination "R2"
	G_P = 13, // Destination "P"
	G_ABBRUCH = 14, // ABORT
	G_SNV = 15, // signal not available
};

/** actual gear */
enum class GS_218h_GIC_EGS52 : uint16_t {
	G_N = 0, // Actual rang "N"
	G_D1 = 1, // actual gear "1"
	G_D2 = 2, // actual gear "2"
	G_D3 = 3, // Actual Rang "3"
	G_D4 = 4, // Actual rang "4"
	G_D5 = 5, // Actual rang "5"
	G_D6 = 6, // actual gear "6"
	G_D7 = 7, // Actual rang "7"
	G_D_CVT = 8, // Actual ranging "infinitely forward
	G_R_CVT = 9, // Actual "infinitely reverse"
	G_R3 = 10, // Actual ranging "R3"
	G_R = 11, // Actual rang "R"
	G_R2 = 12, // Actual rang "R2"s
	G_P = 13, // Actual rang "P"
	G_KRAFTFREI = 14, // power-free
	G_SNV = 15, // signal not available
};

/** Driving program for AAD */
enum class GS_218h_FPC_AAD_EGS52 : uint16_t {
	SPORT = 0, // Sports (standard)
	KOMFORT = 1, // comfort
	UNKNOWN = 2, // not defined
	SNV = 3, // signal not available
};

/** Status Error Check */
enum class GS_218h_FEHLPRF_ST_EGS52 : uint16_t {
	WAIT = 0, // error check not completely run through
	OK = 1, // Completely traject error test, result 0
	ERROR = 2, // Error detected, enter current environmental data
	UNKNOWN = 3, // not defined
};

/** Gear mechanics variant */
enum class GS_418h_MECH_EGS52 : uint16_t {
	GROSS = 0, // Nag, big gear
	KLEIN = 1, // NAG, small gearbox
	GROSS2 = 2, // NAG2, big gear
	KLEIN2 = 3, // NAG2, small gearbox
};

/** target gear */
enum class GS_418h_GZC_EGS52 : uint16_t {
	G_N = 0, // Destination "N"
	G_D1 = 1, // Destination "1"
	G_D2 = 2, // Destination "2"
	G_D3 = 3, // Destination "3"
	G_D4 = 4, // Destination "4"
	G_D5 = 5, // Destination "5"
	G_D6 = 6, // Destination "6"
	G_D7 = 7, // Destination "7"
	G_D_CVT = 8, // Destination "infinitely forward
	G_R_CVT = 9, // Goal "infinitely reverse"
	G_R3 = 10, // Destination "R3"
	G_R = 11, // Destination "R"
	G_R2 = 12, // Destination "R2"
	G_P = 13, // Destination "P"
	G_ABBRUCH = 14, // circuit break
	G_SNV = 15, // signal not available
};

/** actual gear */
enum class GS_418h_GIC_EGS52 : uint16_t {
	G_N = 0, // Actual rang "N"
	G_D1 = 1, // actual gear "1"
	G_D2 = 2, // actual gear "2"
	G_D3 = 3, // Actual Rang "3"
	G_D4 = 4, // Actual rang "4"
	G_D5 = 5, // Actual rang "5"
	G_D6 = 6, // actual gear "6"
	G_D7 = 7, // Actual rang "7"
	G_D_CVT = 8, // Actual ranging "infinitely forward
	G_R_CVT = 9, // Actual "infinitely reverse"
	G_R3 = 10, // Actual ranging "R3"
	G_R = 11, // Actual rang "R"
	G_R2 = 12, // Actual rang "R2"
	G_P = 13, // Actual rang "P"
	G_KRAFTFREI = 14, // power-free
	G_SNV = 15, // signal not available
};

/** gear selector lever position (NAG, KSG, CVT) */
enum class GS_418h_WHST_EGS52 : uint16_t {
	P = 0, // Gear selector lever in position "P"
	R = 1, // gear selector lever in position "R"
	N = 2, // Gear selector lever in position "N"
	D = 4, // gear selector lever in position "D"
	SNV = 7, // signal not available
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** error number or counter for calid / CVN transmission **/
		uint8_t FEHLER: 5;
		/** CALID / CVN transmission active **/
		bool CALID_CVN_AKT: 1;
		/** Status Error Check **/
		GS_218h_FEHLPRF_ST_EGS52 FEHLPRF_ST: 2;
		/** Kriech torque (FFH at EGS, CVT) or Calid / CVN **/
		uint8_t MKRIECH: 8;
		/** Engine Emergency Switch Off **/
		bool MOT_NAUS: 1;
		/** MOT_NAUS-ConfirmMbit **/
		bool MOT_NAUS_CNF: 1;
		/** Convertible bridging clutch load-free **/
		bool K_LSTFR: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING1__: 2;
		/** engagement mode / drive torque control **/
		bool DYN0_AMR_EGS: 1;
		/** engagement mode / drive torque control **/
		bool DYN1_EGS: 1;
		/** Engine torque Request Parity (just parity) **/
		bool MPAR_EGS: 1;
		/** Driving program for AAD **/
		GS_218h_FPC_AAD_EGS52 FPC_AAD: 2;
		/** Kickdown **/
		bool KD: 1;
		/** Overtemperature gearbox **/
		bool UEHITZ_GET: 1;
		/** GS in the emergency **/
		bool GS_NOTL: 1;
		/** reasonable release **/
		bool ALF: 1;
		/** Ball start **/
		bool KS: 1;
		/** gear ok **/
		bool GET_OK: 1;
		/** hand switching mode **/
		bool HSM: 1;
		/** circuit **/
		bool SCHALT: 1;
		/** driving resistance high **/
		bool FW_HOCH: 1;
		/** Basic switch program O.K. **/
		bool GSP_OK: 1;
		/** terrain **/
		bool G_G: 1;
		/** Best. (Transducer overbridge.-) clutch "closed" **/
		bool K_G_B: 1;
		/** Best. (Transducer overbridders.-) clutch "open" **/
		bool K_O_B: 1;
		/** Best. (Transducer overbridge.-) clutch "slip" **/
		bool K_S_B: 1;
		/** actual gear **/
		GS_218h_GIC_EGS52 GIC: 4;
		/** Goal Gang **/
		GS_218h_GZC_EGS52 GZC: 4;
		/** Ford. Engine torque **/
		uint16_t M_EGS: 13;
		/** Engine torque request max **/
		bool MMAX_EGS: 1;
		/** Engine torque request min **/
		bool MMIN_EGS: 1;
		/** Motor moments Toggle 40ms + -10 **/
		bool MTGL_EGS: 1;
	} __attribute__((packed));
	/** Gets CAN ID of GS_218_EGS52 **/
	uint32_t get_canid(){ return GS_218_EGS52_CAN_ID; }
} GS_218_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** Turbine speed (EGS52-NAG, VGS-NAG2) **/
		uint16_t NTURBINE: 16;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint32_t __PADDING1__: 32;
		/** Transmission output speed (only 463/461, other FFFFH) **/
		uint16_t NAB: 16;
	} __attribute__((packed));
	/** Gets CAN ID of GS_338_EGS52 **/
	uint32_t get_canid(){ return GS_338_EGS52_CAN_ID; }
} GS_338_EGS52;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** Factor wheel torque (7ffh at KSG) **/
		uint16_t FMRAD: 11;
		/** gear selector lever position (NAG, KSG, CVT) **/
		GS_418h_WHST_EGS52 WHST: 3;
		/** Factor wheel torque Toggle 40ms + -10 **/
		bool FMRADTGL: 1;
		/** Factor wheel torque parity (straight parity) **/
		bool FMRADPAR: 1;
		/** Loss moment (FFH at KSG) **/
		uint8_t M_VERL: 8;
		/** actual gear **/
		GS_418h_GIC_EGS52 GIC: 4;
		/** target gear **/
		GS_418h_GZC_EGS52 GZC: 4;
		/** Kickdown **/
		bool KD: 1;
		/** Create brake when switching on **/
		bool ESV_BRE: 1;
		/** Gear mechanics variant **/
		GS_418h_MECH_EGS52 MECH: 2;
		/** Stepless transmission [1], stage gear [0] **/
		bool CVT: 1;
		/** circuit **/
		bool SCHALT: 1;
		/** Front drive [1], rear drive [0] **/
		bool FRONT: 1;
		/** four-wheel drive **/
		bool ALLRAD: 1;
		/** Gear oil temperature **/
		uint8_t T_GET: 8;
		/** drive **/
		char FPC: 8;
		/** drive **/
		char FSC: 8;
	} __attribute__((packed));
	/** Gets CAN ID of GS_418_EGS52 **/
	uint32_t get_canid(){ return GS_418_EGS52_CAN_ID; }
} GS_418_EGS52;



class ECU_GS {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            uint8_t idx = 0;
            bool add = true;
            switch(can_id) {
                case GS_218_EGS52_CAN_ID:
                    idx = 0;
                    break;
                case GS_338_EGS52_CAN_ID:
                    idx = 1;
                    break;
                case GS_418_EGS52_CAN_ID:
                    idx = 2;
                    break;
                default:
                    add = false;
                    break;
            }
            if (add) {
                LAST_FRAME_TIMES[idx] = timestamp_now;
                FRAME_DATA[idx] = value;
            }
            return add;
        }
        
        /** Sets data in pointer to GS_218
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GS_218(uint64_t now, uint64_t max_expire_time, GS_218_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[0] <= now && now - LAST_FRAME_TIMES[0] < max_expire_time) {
                dest->raw = FRAME_DATA[0];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to GS_338
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GS_338(uint64_t now, uint64_t max_expire_time, GS_338_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[1] <= now && now - LAST_FRAME_TIMES[1] < max_expire_time) {
                dest->raw = FRAME_DATA[1];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to GS_418
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GS_418(uint64_t now, uint64_t max_expire_time, GS_418_EGS52* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[2] <= now && now - LAST_FRAME_TIMES[2] < max_expire_time) {
                dest->raw = FRAME_DATA[2];
                ret = true;
            }
            return ret;
        }
            
	private:
		uint64_t FRAME_DATA[3];
		uint64_t LAST_FRAME_TIMES[3];
};
#endif // __ECU_GS_H_