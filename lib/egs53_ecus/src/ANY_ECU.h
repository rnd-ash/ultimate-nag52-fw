
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'ANY_ECU'
*/

#ifndef __ECU_ANY_ECU_H_
#define __ECU_ANY_ECU_H_

#include <stdint.h>
    
#define SG_A1_CAN_ID 0x02F7
#define ISM_DISP_RQ_CAN_ID 0x02F5
#define SSP_RS_SSP_CAN_ID 0x0381
#define NM_FSCM2_CAN_ID 0x0435
#define NM_ISM_CAN_ID 0x041D
#define NM_SSP_CAN_ID 0x041E

/** Electric Machine # 1 Diagnostics State / Diagnostic Status E-Machine 1 */
enum class SG_A1_EM1_Diag_Stat {
	IDLE = 0, // No Reaction
	AUTOEPSOFF_ENBL = 1, // carpsof_enable
	LHOM = 2, // LIMP Home
	TRQ_RED = 3, // Torque Reduce
	SPD_RED = 4, // Speed Reduce
	ASC_ACTV = 5, // ASC Active
	TPC_ACTV = 6, // TPC Active
	PREVENT = 7, // Prevent Operation
	SNA = 255, // Signal Not Available
};

/** Error Check State / Status Error Check */
enum class SG_A1_SG_ErrChk_Stat {
	WAIT = 0, // Error Test Not Yet Finished
	OK = 1, // Error Test Finished, result is ok
	ERROR = 2, // Error Detected, Record Actual Data
	NDEF3 = 3, // Not Defined
};

/** Transmission Driving Position Display Request / Request Display Gearbox */
enum class ISM_DISP_RQ_TxDrvPosn_Disp_Rq_ISM {
	M1 = 1, // Driving position "M1"
	M2 = 2, // Driving position "M2"
	M3 = 3, // Driving position "M3"
	M4 = 4, // driving position "M4"
	M5 = 5, // Driving position "M5"
	M6 = 6, // Driving position "M6"
	M7 = 7, // Driving position "M7"
	BLANK = 32, // blank ("")
	D1 = 49, // driving position "D1"
	D2 = 50, // Driving position "D2"
	D3 = 51, // Driving position "D3"
	D4 = 52, // Driving position "D4"
	D5 = 53, // Driving position "D5"
	D6 = 54, // Driving position "D6"
	D7 = 55, // Driving position "D7"
	A = 65, // Driving position "A"
	D = 68, // Driving position "D"
	F = 70, // Fault Label "F"
	N = 78, // Driving position "N"
	P = 80, // driving position "P"
	R = 82, // Driving position "R"
	SNA = 255, // Signal Not Available
};

/** Shift by Wire Message Display Request / Request Shift by Wire Show message */
enum class ISM_DISP_RQ_SBW_Msg_Disp_Rq_ISM {
	IDLE = 0, // No Message
	M1 = 1, // Message 1
	M2 = 2, // Message 2
	M3 = 3, // Message 3
	M4 = 4, // Message 4
	M5 = 5, // Message 5
	M6 = 6, // Message 6
	NDEF7 = 7, // Not Defined
};

/** Transmission Selector Lever Motion Lock 2 Display Request / Request Transmission Lock Lock 2 Display */
enum class ISM_DISP_RQ_TSL_MtnLk2_Disp_Rq_ISM {
	IDLE = 0, // No Lock icon display
	ARR_UP = 1, // Lock icon arrow up
	ARR_DN = 2, // Lock Symbol Arrow Down
	ARR_LT = 3, // Lock Symbol Arrow Left
	ARR_UP_DN = 4, // Lock Symbol Arrow Up and Down
	ARR_UP_HLGT = 9, // Lock icon arrow up highlighted
	ARR_DN_HLGT = 10, // Lock Symbol Arrow Down Highlighted
	ARR_LT_HLGT = 11, // Lock Symbol Arrow Left Highlighted
	ARR_UP_DN_HLGT = 12, // Lock Symbol Arrow Up and Down Highlighted
};

/** Transmission Selector Lever Motion Lock 1 Display Request / Request Transmission Lock Lock 1 Display */
enum class ISM_DISP_RQ_TSL_MtnLk1_Disp_Rq_ISM {
	IDLE = 0, // No Lock icon display
	ARR_UP = 1, // Lock icon arrow up
	ARR_DN = 2, // Lock Symbol Arrow Down
	ARR_LT = 3, // Lock Symbol Arrow Left
	ARR_UP_DN = 4, // Lock Symbol Arrow Up and Down
	ARR_UP_HLGT = 9, // Lock icon arrow up highlighted
	ARR_DN_HLGT = 10, // Lock Symbol Arrow Down Highlighted
	ARR_LT_HLGT = 11, // Lock Symbol Arrow Left Highlighted
	ARR_UP_DN_HLGT = 12, // Lock Symbol Arrow Up and Down Highlighted
};

/** Transmission Selector Lever Motion Lock 4 Display Request / Request Transmission Lock Lock 4 Display */
enum class ISM_DISP_RQ_TSL_MtnLk4_Disp_Rq_ISM {
	IDLE = 0, // No Lock icon display
	ARR_UP = 1, // Lock icon arrow up
	ARR_DN = 2, // Lock Symbol Arrow Down
	ARR_LT = 3, // Lock Symbol Arrow Left
	ARR_UP_DN = 4, // Lock Symbol Arrow Up and Down
	ARR_UP_HLGT = 9, // Lock icon arrow up highlighted
	ARR_DN_HLGT = 10, // Lock Symbol Arrow Down Highlighted
	ARR_LT_HLGT = 11, // Lock Symbol Arrow Left Highlighted
	ARR_UP_DN_HLGT = 12, // Lock Symbol Arrow Up and Down Highlighted
};

/** Transmission Selector Lever Motion Lock 3 Display Request / Request Transmission Lock Lock 3 Display */
enum class ISM_DISP_RQ_TSL_MtnLk3_Disp_Rq_ISM {
	IDLE = 0, // No Lock icon display
	ARR_UP = 1, // Lock icon arrow up
	ARR_DN = 2, // Lock Symbol Arrow Down
	ARR_LT = 3, // Lock Symbol Arrow Left
	ARR_UP_DN = 4, // Lock Symbol Arrow Up and Down
	ARR_UP_HLGT = 9, // Lock icon arrow up highlighted
	ARR_DN_HLGT = 10, // Lock Symbol Arrow Down Highlighted
	ARR_LT_HLGT = 11, // Lock Symbol Arrow Left Highlighted
	ARR_UP_DN_HLGT = 12, // Lock Symbol Arrow Up and Down Highlighted
};

/** SSP Diagnostics State / SSP Diagnostic Status */
enum class SSP_RS_SSP_SSP_Diag_Stat {
	OK = 0, // No Fault
	CURR = 1, // Nominal Current Not Obtained
	VOLT = 2, // Voltage
	TEMP = 3, // Temperature
	DEBOUNCE_CNT = 4, // Debounce Counter
	TIMEOUT = 5, // Timeout
	LK = 128, // locking
	IDLE = 129, // idle
	SHRT = 130, // Short Circuit
	SEMI = 131, // Semiconductor Fault
	CAN = 132, // CAN SPECIFIC FAULT
};

/** Network Management Mode / Network Management Mode */
enum class NM_FSCM2_NM_Mode {
	LHOM = 252, // LIMP-HOME Fashion
	RING = 253, // ring fashion
	ALIVE = 254, // Alive mode
	SNA = 255, // Signal Not Available
};

/** Network Management UserData Launch Type / Network Management UserData Sendart */
enum class NM_FSCM2_NM_Ud_Launch {
	BROADCAST = 4, // Broadcast or Start Alive
	SNA = 63, // Signal Not Available
};

/** Network Management UserData Service No./netzmanagement UserData service */
enum class NM_FSCM2_NM_Ud_Srv {
	DATA_OK_BC = 1, // UserData Transmission OK (Broadcast)
	WAKEUP_SA = 2, // Wakeup status (start alive)
	SBC_STAT_BC = 5, // System Base Chip Status (Broadcast)
	AWAKE_BC = 15, // Stay Awake Reason (Broadcast)
	SNA = 255, // Signal Not Available
};

/** Wakeup Reason / Wake-up */
enum class NM_FSCM2_WakeupRsn_FSCM2 {
	NETWORK = 0, // Wakeup by Network
	SNA = 255, // Signal Not Available
};

/** Network Identification No./netzwerk-id */
enum class NM_FSCM2_Nw_Id {
	BACKBONE = 4, // Backbone CAN
	DIAGNOSTICS = 5, // Diagnostics CAN
	BODY = 6, // Body CAN
	CHASSIS = 7, // Chassis CAN
	POWERTRAIN = 8, // Powertrain Can
	PT_SENSOR = 9, // Powertrain Sensor CAN
	DYNAMICS = 11, // Dynamics CAN
	HEADUNIT = 14, // HeadUnit CAN
	IMPACT = 15, // Impact CAN
	MULTIPURPOSE = 16, // Multipurpose CAN
	SNA = 255, // Signal Not Available
};

/** Network Management Mode / Network Management Mode */
enum class NM_ISM_NM_Mode {
	LHOM = 252, // LIMP-HOME Fashion
	RING = 253, // ring fashion
	ALIVE = 254, // Alive mode
	SNA = 255, // Signal Not Available
};

/** Network Management UserData Launch Type / Network Management UserData Sendart */
enum class NM_ISM_NM_Ud_Launch {
	BROADCAST = 4, // Broadcast or Start Alive
	SNA = 63, // Signal Not Available
};

/** Network Management UserData Service No./netzmanagement UserData service */
enum class NM_ISM_NM_Ud_Srv {
	DATA_OK_BC = 1, // UserData Transmission OK (Broadcast)
	WAKEUP_SA = 2, // Wakeup status (start alive)
	SBC_STAT_BC = 5, // System Base Chip Status (Broadcast)
	AWAKE_BC = 15, // Stay Awake Reason (Broadcast)
	SNA = 255, // Signal Not Available
};

/** Wakeup Reason / Wake-up */
enum class NM_ISM_WakeupRsn_ISM {
	NETWORK = 0, // Wakeup by Network
	SNA = 255, // Signal Not Available
};

/** Network Identification No./netzwerk-id */
enum class NM_ISM_Nw_Id {
	BACKBONE = 4, // Backbone CAN
	DIAGNOSTICS = 5, // Diagnostics CAN
	BODY = 6, // Body CAN
	CHASSIS = 7, // Chassis CAN
	POWERTRAIN = 8, // Powertrain Can
	PT_SENSOR = 9, // Powertrain Sensor CAN
	DYNAMICS = 11, // Dynamics CAN
	HEADUNIT = 14, // HeadUnit CAN
	IMPACT = 15, // Impact CAN
	MULTIPURPOSE = 16, // Multipurpose CAN
	SNA = 255, // Signal Not Available
};

/** Network Management Mode / Network Management Mode */
enum class NM_SSP_NM_Mode {
	LHOM = 252, // LIMP-HOME Fashion
	RING = 253, // ring fashion
	ALIVE = 254, // Alive mode
	SNA = 255, // Signal Not Available
};

/** Network Management UserData Launch Type / Network Management UserData Sendart */
enum class NM_SSP_NM_Ud_Launch {
	BROADCAST = 4, // Broadcast or Start Alive
	SNA = 63, // Signal Not Available
};

/** Network Management UserData Service No./netzmanagement UserData service */
enum class NM_SSP_NM_Ud_Srv {
	DATA_OK_BC = 1, // UserData Transmission OK (Broadcast)
	WAKEUP_SA = 2, // Wakeup status (start alive)
	SBC_STAT_BC = 5, // System Base Chip Status (Broadcast)
	AWAKE_BC = 15, // Stay Awake Reason (Broadcast)
	SNA = 255, // Signal Not Available
};

/** Wakeup Reason / Wake-up */
enum class NM_SSP_WakeupRsn_SSP {
	NETWORK = 0, // Wakeup by Network
	SNA = 255, // Signal Not Available
};

/** Network Identification No./netzwerk-id */
enum class NM_SSP_Nw_Id {
	BACKBONE = 4, // Backbone CAN
	DIAGNOSTICS = 5, // Diagnostics CAN
	BODY = 6, // Body CAN
	CHASSIS = 7, // Chassis CAN
	POWERTRAIN = 8, // Powertrain Can
	PT_SENSOR = 9, // Powertrain Sensor CAN
	DYNAMICS = 11, // Dynamics CAN
	HEADUNIT = 14, // HeadUnit CAN
	IMPACT = 15, // Impact CAN
	MULTIPURPOSE = 16, // Multipurpose CAN
	SNA = 255, // Signal Not Available
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SG_A1 */
	uint32_t get_canid(){ return SG_A1_CAN_ID; }
    /** Sets Starter / Generator Output DC Current / DC Current. Conversion formula (To raw from real): y=(x+3276.60009765625)/0.10 (Unit: A) */
    void set_SG_OutDC_Curr(uint16_t value){ raw = (raw & 0x0000ffffffffffff) | ((uint64_t)value & 0xffff) << 48; }

    /** Gets Starter / Generator Output DC Current / DC Current. Conversion formula (To real from raw): y=(0.10x)-3276.60009765625 (Unit: A) */
    uint16_t get_SG_OutDC_Curr() const { return (uint16_t)(raw >> 48 & 0xffff); }
        
    /** Sets Starter / Generator Output DC Voltage / DC Voltage. Conversion formula (To raw from real): y=(x-0.0)/0.10 (Unit: V) */
    void set_SG_OutDC_Volt(uint16_t value){ raw = (raw & 0xffff0000ffffffff) | ((uint64_t)value & 0xffff) << 32; }

    /** Gets Starter / Generator Output DC Voltage / DC Voltage. Conversion formula (To real from raw): y=(0.10x)+0.0 (Unit: V) */
    uint16_t get_SG_OutDC_Volt() const { return (uint16_t)(raw >> 32 & 0xffff); }
        
    /** Sets Electric Machine # 1 Diagnostics State / Diagnostic Status E-Machine 1 */
    void set_EM1_Diag_Stat(SG_A1_EM1_Diag_Stat value){ raw = (raw & 0xffffffffffff00ff) | ((uint64_t)value & 0xff) << 8; }

    /** Gets Electric Machine # 1 Diagnostics State / Diagnostic Status E-Machine 1 */
    SG_A1_EM1_Diag_Stat get_EM1_Diag_Stat() const { return (SG_A1_EM1_Diag_Stat)(raw >> 8 & 0xff); }
        
    /** Sets Error Check State / Status Error Check */
    void set_SG_ErrChk_Stat(SG_A1_SG_ErrChk_Stat value){ raw = (raw & 0xffffffffffffff3f) | ((uint64_t)value & 0x3) << 6; }

    /** Gets Error Check State / Status Error Check */
    SG_A1_SG_ErrChk_Stat get_SG_ErrChk_Stat() const { return (SG_A1_SG_ErrChk_Stat)(raw >> 6 & 0x3); }
        
    /** Sets Electric Machine # 1 Enhanced Cooling Request / Request Advanced Cooling of the E-Machine 1 */
    void set_EM1_EnhCool_Rq(bool value){ raw = (raw & 0xffffffffffffffdf) | ((uint64_t)value & 0x1) << 5; }

    /** Gets Electric Machine # 1 Enhanced Cooling Request / Request Advanced Cooling of the E-Machine 1 */
    bool get_EM1_EnhCool_Rq() const { return (bool)(raw >> 5 & 0x1); }
        
    /** Sets Error Number / Error Number. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_EM1_ErrNum(uint8_t value){ raw = (raw & 0xffffffffffffffe0) | ((uint64_t)value & 0x1f) << 0; }

    /** Gets Error Number / Error Number. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_EM1_ErrNum() const { return (uint8_t)(raw >> 0 & 0x1f); }
        
} SG_A1;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of ISM_DISP_RQ */
	uint32_t get_canid(){ return ISM_DISP_RQ_CAN_ID; }
    /** Sets Transmission Driving Position Display Request / Request Display Gearbox */
    void set_TxDrvPosn_Disp_Rq_ISM(ISM_DISP_RQ_TxDrvPosn_Disp_Rq_ISM value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Transmission Driving Position Display Request / Request Display Gearbox */
    ISM_DISP_RQ_TxDrvPosn_Disp_Rq_ISM get_TxDrvPosn_Disp_Rq_ISM() const { return (ISM_DISP_RQ_TxDrvPosn_Disp_Rq_ISM)(raw >> 56 & 0xff); }
        
    /** Sets Shift by Wire Beep Request / Request Shift by Wire Warnington */
    void set_SBW_Beep_Rq_ISM(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Shift by Wire Beep Request / Request Shift by Wire Warnington */
    bool get_SBW_Beep_Rq_ISM() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Shift by Wire Message Display Request / Request Shift by Wire Show message */
    void set_SBW_Msg_Disp_Rq_ISM(ISM_DISP_RQ_SBW_Msg_Disp_Rq_ISM value){ raw = (raw & 0xfffff8ffffffffff) | ((uint64_t)value & 0x7) << 40; }

    /** Gets Shift by Wire Message Display Request / Request Shift by Wire Show message */
    ISM_DISP_RQ_SBW_Msg_Disp_Rq_ISM get_SBW_Msg_Disp_Rq_ISM() const { return (ISM_DISP_RQ_SBW_Msg_Disp_Rq_ISM)(raw >> 40 & 0x7); }
        
    /** Sets Transmission Selector Lever Motion Lock 2 Display Request / Request Transmission Lock Lock 2 Display */
    void set_TSL_MtnLk2_Disp_Rq_ISM(ISM_DISP_RQ_TSL_MtnLk2_Disp_Rq_ISM value){ raw = (raw & 0xffffff0fffffffff) | ((uint64_t)value & 0xf) << 36; }

    /** Gets Transmission Selector Lever Motion Lock 2 Display Request / Request Transmission Lock Lock 2 Display */
    ISM_DISP_RQ_TSL_MtnLk2_Disp_Rq_ISM get_TSL_MtnLk2_Disp_Rq_ISM() const { return (ISM_DISP_RQ_TSL_MtnLk2_Disp_Rq_ISM)(raw >> 36 & 0xf); }
        
    /** Sets Transmission Selector Lever Motion Lock 1 Display Request / Request Transmission Lock Lock 1 Display */
    void set_TSL_MtnLk1_Disp_Rq_ISM(ISM_DISP_RQ_TSL_MtnLk1_Disp_Rq_ISM value){ raw = (raw & 0xfffffff0ffffffff) | ((uint64_t)value & 0xf) << 32; }

    /** Gets Transmission Selector Lever Motion Lock 1 Display Request / Request Transmission Lock Lock 1 Display */
    ISM_DISP_RQ_TSL_MtnLk1_Disp_Rq_ISM get_TSL_MtnLk1_Disp_Rq_ISM() const { return (ISM_DISP_RQ_TSL_MtnLk1_Disp_Rq_ISM)(raw >> 32 & 0xf); }
        
    /** Sets Transmission Selector Lever Motion Lock 4 Display Request / Request Transmission Lock Lock 4 Display */
    void set_TSL_MtnLk4_Disp_Rq_ISM(ISM_DISP_RQ_TSL_MtnLk4_Disp_Rq_ISM value){ raw = (raw & 0xffffffff0fffffff) | ((uint64_t)value & 0xf) << 28; }

    /** Gets Transmission Selector Lever Motion Lock 4 Display Request / Request Transmission Lock Lock 4 Display */
    ISM_DISP_RQ_TSL_MtnLk4_Disp_Rq_ISM get_TSL_MtnLk4_Disp_Rq_ISM() const { return (ISM_DISP_RQ_TSL_MtnLk4_Disp_Rq_ISM)(raw >> 28 & 0xf); }
        
    /** Sets Transmission Selector Lever Motion Lock 3 Display Request / Request Transmission Lock Lock 3 Display */
    void set_TSL_MtnLk3_Disp_Rq_ISM(ISM_DISP_RQ_TSL_MtnLk3_Disp_Rq_ISM value){ raw = (raw & 0xfffffffff0ffffff) | ((uint64_t)value & 0xf) << 24; }

    /** Gets Transmission Selector Lever Motion Lock 3 Display Request / Request Transmission Lock Lock 3 Display */
    ISM_DISP_RQ_TSL_MtnLk3_Disp_Rq_ISM get_TSL_MtnLk3_Disp_Rq_ISM() const { return (ISM_DISP_RQ_TSL_MtnLk3_Disp_Rq_ISM)(raw >> 24 & 0xf); }
        
} ISM_DISP_RQ;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SSP_RS_SSP */
	uint32_t get_canid(){ return SSP_RS_SSP_CAN_ID; }
    /** Sets Actual Current Duty Cycle / Actual Electricity (duty cycle). Conversion formula (To raw from real): y=(x-0.0)/0.50 (Unit: %) */
    void set_CurrDtyCyc_Actl(uint8_t value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Actual Current Duty Cycle / Actual Electricity (duty cycle). Conversion formula (To real from raw): y=(0.50x)+0.0 (Unit: %) */
    uint8_t get_CurrDtyCyc_Actl() const { return (uint8_t)(raw >> 56 & 0xff); }
        
    /** Sets SSP Diagnostics State / SSP Diagnostic Status */
    void set_SSP_Diag_Stat(SSP_RS_SSP_SSP_Diag_Stat value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets SSP Diagnostics State / SSP Diagnostic Status */
    SSP_RS_SSP_SSP_Diag_Stat get_SSP_Diag_Stat() const { return (SSP_RS_SSP_SSP_Diag_Stat)(raw >> 48 & 0xff); }
        
    /** Sets ACTUAL RPM SSP / Current SSP speed. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: rpm) */
    void set_SSP_RPM(uint16_t value){ raw = (raw & 0xffffffc000ffffff) | ((uint64_t)value & 0x3fff) << 24; }

    /** Gets ACTUAL RPM SSP / Current SSP speed. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: rpm) */
    uint16_t get_SSP_RPM() const { return (uint16_t)(raw >> 24 & 0x3fff); }
        
    /** Sets Message Counter / Message Counter. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_MC_SSP_RS_SSP(uint8_t value){ raw = (raw & 0xffffffffffff0fff) | ((uint64_t)value & 0xf) << 12; }

    /** Gets Message Counter / Message Counter. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_MC_SSP_RS_SSP() const { return (uint8_t)(raw >> 12 & 0xf); }
        
    /** Sets CRC Checksum Byte 1 to 7 Accordinging to SAE J1850 / CRC Checksum Byte 1 - 7 to SAE J1850. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_CRC_SSP_RS_SSP(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets CRC Checksum Byte 1 to 7 Accordinging to SAE J1850 / CRC Checksum Byte 1 - 7 to SAE J1850. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_CRC_SSP_RS_SSP() const { return (uint8_t)(raw >> 0 & 0xff); }
        
} SSP_RS_SSP;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of NM_FSCM2 */
	uint32_t get_canid(){ return NM_FSCM2_CAN_ID; }
    /** Sets Network Management Mode / Network Management Mode */
    void set_NM_Mode(NM_FSCM2_NM_Mode value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Network Management Mode / Network Management Mode */
    NM_FSCM2_NM_Mode get_NM_Mode() const { return (NM_FSCM2_NM_Mode)(raw >> 56 & 0xff); }
        
    /** Sets Network Management Logical Successor / Network Management Logical Successor. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_NM_Successor(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Network Management Logical Successor / Network Management Logical Successor. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_NM_Successor() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Network Management Sleep Indication / Network Management Sleep Indication */
    void set_NM_Sleep_Ind(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Network Management Sleep Indication / Network Management Sleep Indication */
    bool get_NM_Sleep_Ind() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Network Management Sleep Acknowledge / Network Management Sleep Acknowledge */
    void set_NM_Sleep_Ack(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Network Management Sleep Acknowledge / Network Management Sleep Acknowledge */
    bool get_NM_Sleep_Ack() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Network Management UserData Launch Type / Network Management UserData Sendart */
    void set_NM_Ud_Launch(NM_FSCM2_NM_Ud_Launch value){ raw = (raw & 0xffffc0ffffffffff) | ((uint64_t)value & 0x3f) << 40; }

    /** Gets Network Management UserData Launch Type / Network Management UserData Sendart */
    NM_FSCM2_NM_Ud_Launch get_NM_Ud_Launch() const { return (NM_FSCM2_NM_Ud_Launch)(raw >> 40 & 0x3f); }
        
    /** Sets Network Management UserData Service No./netzmanagement UserData service */
    void set_NM_Ud_Srv(NM_FSCM2_NM_Ud_Srv value){ raw = (raw & 0xffffff00ffffffff) | ((uint64_t)value & 0xff) << 32; }

    /** Gets Network Management UserData Service No./netzmanagement UserData service */
    NM_FSCM2_NM_Ud_Srv get_NM_Ud_Srv() const { return (NM_FSCM2_NM_Ud_Srv)(raw >> 32 & 0xff); }
        
    /** Sets Wakeup Reason / Wake-up */
    void set_WakeupRsn_FSCM2(NM_FSCM2_WakeupRsn_FSCM2 value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets Wakeup Reason / Wake-up */
    NM_FSCM2_WakeupRsn_FSCM2 get_WakeupRsn_FSCM2() const { return (NM_FSCM2_WakeupRsn_FSCM2)(raw >> 24 & 0xff); }
        
    /** Sets Counter for Module Wakeup States During Network Sleep / Counter for ECUs Internal Wachzustäustände during bus rest. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_WakeupCnt(uint8_t value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Counter for Module Wakeup States During Network Sleep / Counter for ECUs Internal Wachzustäustände during bus rest. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_WakeupCnt() const { return (uint8_t)(raw >> 16 & 0xff); }
        
    /** Sets Network Identification No./netzwerk-id */
    void set_Nw_Id(NM_FSCM2_Nw_Id value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets Network Identification No./netzwerk-id */
    NM_FSCM2_Nw_Id get_Nw_Id() const { return (NM_FSCM2_Nw_Id)(raw >> 0 & 0xff); }
        
} NM_FSCM2;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of NM_ISM */
	uint32_t get_canid(){ return NM_ISM_CAN_ID; }
    /** Sets Network Management Mode / Network Management Mode */
    void set_NM_Mode(NM_ISM_NM_Mode value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Network Management Mode / Network Management Mode */
    NM_ISM_NM_Mode get_NM_Mode() const { return (NM_ISM_NM_Mode)(raw >> 56 & 0xff); }
        
    /** Sets Network Management Logical Successor / Network Management Logical Successor. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_NM_Successor(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Network Management Logical Successor / Network Management Logical Successor. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_NM_Successor() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Network Management Sleep Indication / Network Management Sleep Indication */
    void set_NM_Sleep_Ind(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Network Management Sleep Indication / Network Management Sleep Indication */
    bool get_NM_Sleep_Ind() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Network Management Sleep Acknowledge / Network Management Sleep Acknowledge */
    void set_NM_Sleep_Ack(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Network Management Sleep Acknowledge / Network Management Sleep Acknowledge */
    bool get_NM_Sleep_Ack() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Network Management UserData Launch Type / Network Management UserData Sendart */
    void set_NM_Ud_Launch(NM_ISM_NM_Ud_Launch value){ raw = (raw & 0xffffc0ffffffffff) | ((uint64_t)value & 0x3f) << 40; }

    /** Gets Network Management UserData Launch Type / Network Management UserData Sendart */
    NM_ISM_NM_Ud_Launch get_NM_Ud_Launch() const { return (NM_ISM_NM_Ud_Launch)(raw >> 40 & 0x3f); }
        
    /** Sets Network Management UserData Service No./netzmanagement UserData service */
    void set_NM_Ud_Srv(NM_ISM_NM_Ud_Srv value){ raw = (raw & 0xffffff00ffffffff) | ((uint64_t)value & 0xff) << 32; }

    /** Gets Network Management UserData Service No./netzmanagement UserData service */
    NM_ISM_NM_Ud_Srv get_NM_Ud_Srv() const { return (NM_ISM_NM_Ud_Srv)(raw >> 32 & 0xff); }
        
    /** Sets Wakeup Reason / Wake-up */
    void set_WakeupRsn_ISM(NM_ISM_WakeupRsn_ISM value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets Wakeup Reason / Wake-up */
    NM_ISM_WakeupRsn_ISM get_WakeupRsn_ISM() const { return (NM_ISM_WakeupRsn_ISM)(raw >> 24 & 0xff); }
        
    /** Sets Counter for Module Wakeup States During Network Sleep / Counter for ECUs Internal Wachzustäustände during bus rest. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_WakeupCnt(uint8_t value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Counter for Module Wakeup States During Network Sleep / Counter for ECUs Internal Wachzustäustände during bus rest. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_WakeupCnt() const { return (uint8_t)(raw >> 16 & 0xff); }
        
    /** Sets Network Identification No./netzwerk-id */
    void set_Nw_Id(NM_ISM_Nw_Id value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets Network Identification No./netzwerk-id */
    NM_ISM_Nw_Id get_Nw_Id() const { return (NM_ISM_Nw_Id)(raw >> 0 & 0xff); }
        
} NM_ISM;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of NM_SSP */
	uint32_t get_canid(){ return NM_SSP_CAN_ID; }
    /** Sets Network Management Mode / Network Management Mode */
    void set_NM_Mode(NM_SSP_NM_Mode value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Network Management Mode / Network Management Mode */
    NM_SSP_NM_Mode get_NM_Mode() const { return (NM_SSP_NM_Mode)(raw >> 56 & 0xff); }
        
    /** Sets Network Management Logical Successor / Network Management Logical Successor. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_NM_Successor(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Network Management Logical Successor / Network Management Logical Successor. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_NM_Successor() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Network Management Sleep Indication / Network Management Sleep Indication */
    void set_NM_Sleep_Ind(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Network Management Sleep Indication / Network Management Sleep Indication */
    bool get_NM_Sleep_Ind() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Network Management Sleep Acknowledge / Network Management Sleep Acknowledge */
    void set_NM_Sleep_Ack(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Network Management Sleep Acknowledge / Network Management Sleep Acknowledge */
    bool get_NM_Sleep_Ack() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Network Management UserData Launch Type / Network Management UserData Sendart */
    void set_NM_Ud_Launch(NM_SSP_NM_Ud_Launch value){ raw = (raw & 0xffffc0ffffffffff) | ((uint64_t)value & 0x3f) << 40; }

    /** Gets Network Management UserData Launch Type / Network Management UserData Sendart */
    NM_SSP_NM_Ud_Launch get_NM_Ud_Launch() const { return (NM_SSP_NM_Ud_Launch)(raw >> 40 & 0x3f); }
        
    /** Sets Network Management UserData Service No./netzmanagement UserData service */
    void set_NM_Ud_Srv(NM_SSP_NM_Ud_Srv value){ raw = (raw & 0xffffff00ffffffff) | ((uint64_t)value & 0xff) << 32; }

    /** Gets Network Management UserData Service No./netzmanagement UserData service */
    NM_SSP_NM_Ud_Srv get_NM_Ud_Srv() const { return (NM_SSP_NM_Ud_Srv)(raw >> 32 & 0xff); }
        
    /** Sets Wakeup Reason / Wake-up */
    void set_WakeupRsn_SSP(NM_SSP_WakeupRsn_SSP value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets Wakeup Reason / Wake-up */
    NM_SSP_WakeupRsn_SSP get_WakeupRsn_SSP() const { return (NM_SSP_WakeupRsn_SSP)(raw >> 24 & 0xff); }
        
    /** Sets Counter for Module Wakeup States During Network Sleep / Counter for ECUs Internal Wachzustäustände during bus rest. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_WakeupCnt(uint8_t value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Counter for Module Wakeup States During Network Sleep / Counter for ECUs Internal Wachzustäustände during bus rest. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_WakeupCnt() const { return (uint8_t)(raw >> 16 & 0xff); }
        
    /** Sets Network Identification No./netzwerk-id */
    void set_Nw_Id(NM_SSP_Nw_Id value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets Network Identification No./netzwerk-id */
    NM_SSP_Nw_Id get_Nw_Id() const { return (NM_SSP_Nw_Id)(raw >> 0 & 0xff); }
        
} NM_SSP;



class ECU_ANY_ECU {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case SG_A1_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case ISM_DISP_RQ_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                case SSP_RS_SSP_CAN_ID:
                    LAST_FRAME_TIMES[2] = timestamp_now;
                    FRAME_DATA[2] = value;
                    return true;
                case NM_FSCM2_CAN_ID:
                    LAST_FRAME_TIMES[3] = timestamp_now;
                    FRAME_DATA[3] = value;
                    return true;
                case NM_ISM_CAN_ID:
                    LAST_FRAME_TIMES[4] = timestamp_now;
                    FRAME_DATA[4] = value;
                    return true;
                case NM_SSP_CAN_ID:
                    LAST_FRAME_TIMES[5] = timestamp_now;
                    FRAME_DATA[5] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to SG_A1
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SG_A1(uint64_t now, uint64_t max_expire_time, SG_A1* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[0] && now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
        /** Sets data in pointer to ISM_DISP_RQ
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ISM_DISP_RQ(uint64_t now, uint64_t max_expire_time, ISM_DISP_RQ* dest) const {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[1] && now - LAST_FRAME_TIMES[1] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[1];
                return true;
            }
        }
            
        /** Sets data in pointer to SSP_RS_SSP
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SSP_RS_SSP(uint64_t now, uint64_t max_expire_time, SSP_RS_SSP* dest) const {
            if (LAST_FRAME_TIMES[2] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[2] && now - LAST_FRAME_TIMES[2] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[2];
                return true;
            }
        }
            
        /** Sets data in pointer to NM_FSCM2
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_NM_FSCM2(uint64_t now, uint64_t max_expire_time, NM_FSCM2* dest) const {
            if (LAST_FRAME_TIMES[3] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[3] && now - LAST_FRAME_TIMES[3] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[3];
                return true;
            }
        }
            
        /** Sets data in pointer to NM_ISM
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_NM_ISM(uint64_t now, uint64_t max_expire_time, NM_ISM* dest) const {
            if (LAST_FRAME_TIMES[4] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[4] && now - LAST_FRAME_TIMES[4] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[4];
                return true;
            }
        }
            
        /** Sets data in pointer to NM_SSP
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_NM_SSP(uint64_t now, uint64_t max_expire_time, NM_SSP* dest) const {
            if (LAST_FRAME_TIMES[5] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[5] && now - LAST_FRAME_TIMES[5] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[5];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[6];
		uint64_t LAST_FRAME_TIMES[6];
};
#endif // __ECU_ANY_ECU_H_