
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'MS'
*/

#ifndef __ECU_MS_H_
#define __ECU_MS_H_

#include <stdint.h>
    
#define MS_210_CAN_ID 0x0210
#define MS_212_CAN_ID 0x0212
#define MS_268_CAN_ID 0x0268
#define MS_2F3_CAN_ID 0x02F3
#define MS_308_CAN_ID 0x0308
#define MS_312_CAN_ID 0x0312
#define AAD_580_CAN_ID 0x0580
#define MS_608_CAN_ID 0x0608

/** switching line shift MS */
enum class MS_210h_SLV_MS {
	SKL0 = 0, // Shift characteristic "0"
	SKL1 = 1, // Shift characteristic "1"
	SKL2 = 2, // Shift characteristic "2"
	SKL3 = 3, // Shift characteristic "3"
	SKL4 = 4, // Shift characteristic "4"
	SKL5 = 5, // Shift characteristic "5"
	SKL6 = 6, // Shift characteristic "6"
	SKL7 = 7, // Shift characteristic "7"
	SKL8 = 8, // Shift characteristic "8"
	SKL9 = 9, // Shift characteristic "9"
	SKL10 = 10, // Shift characteristic "10"
};

/** Gear, upper limit */
enum class MS_210h_GMAX_MS {
	PASSIVE = 0, // passive value
	G1 = 1, // Gear, upper limit = 1
	G2 = 2, // Gear, upper limit = 2
	G3 = 3, // Gear, upper limit = 3
	G4 = 4, // Gear, upper limit = 4
	G5 = 5, // Gear, upper limit = 5
	G6 = 6, // Gear, upper limit = 6
	G7 = 7, // Gear, upper limit = 7
};

/** Gear, lower limit */
enum class MS_210h_GMIN_MS {
	PASSIVE = 0, // passive value
	G1 = 1, // Gear, lower limit = 1
	G2 = 2, // Gear, lower limit = 2
	G3 = 3, // Gear, lower limit = 3
	G4 = 4, // Gear, lower limit = 4
	G5 = 5, // Gear, lower limit = 5
	G6 = 6, // Gear, lower limit = 6
	G7 = 7, // Gear, lower limit = 7
};

/** Status heating power */
enum class MS_268h_HZL_ST {
	ZU = 0, // Heating shut-off valve is too
	AUF = 1, // Heating shut-off valve is up
	TAKT = 2, // Heating shut-off valve is clocked
	SNV = 3, // signal not available
};

/** Drive Level Switching recommendation "is" */
enum class MS_2F3h_FSC_IST {
	BLANK = 32, // Blank ("")
	EINS = 49, // Driving Level "1"
	ZWEI = 50, // Driving Level "2"
	DREI = 51, // Driving Level "3"
	VIER = 52, // Driving Level "4"
	FUENF = 53, // Driving Level "5"
	SECHS = 54, // Driving Level "6"
	SIEBEN = 55, // Driving stage "7"
	A = 65, // Driving stage "A"
	D = 68, // speed "D"
	F = 70, // Error Mark "F"
	N = 78, // Driving "N"
	P = 80, // Driving Level "P"
	R = 82, // Driving "R"
	SNV = 255, // passive value
};

/** Drive Level Switching recommendation "should" */
enum class MS_2F3h_FSC_SOLL {
	HOCH = 1, // "upshift" / arrow
	RUNTER = 2, // "downshift" / arrow
	BLANK_OR_PAS = 32, // blank ("") / passive
	EINS = 49, // Driving Level "1"
	ZWEI = 50, // Driving Level "2"
	DREI = 51, // Driving Level "3"
	VIER = 52, // Driving Level "4"
	FUENF = 53, // Driving Level "5"
	SECHS = 54, // Driving Level "6"
	SIEBEN = 55, // Driving stage "7"
	A = 65, // Driving stage "A"
	D = 68, // speed "D"
	F = 70, // Error Mark "F"
	N = 78, // Driving "N"
	P = 80, // Driving Level "P"
	R = 82, // Driving "R"
	SNV = 255, // passive value
};

/** Vehicle code body */
enum class MS_608h_FCOD_KAR {
	W = 0, // W - Limousine (or G short BM1 / 3 at BR 463, G at 461)
	V = 1, // V - Limousine long (or VF at BR 210/211, G Lang BM6 at BR 463)
	C = 2, // C - Coupé (or VV at BR 210/211/220)
	S = 3, // S - T model (or special protection B4 at BR W240, T at BR 245)
	A = 4, // A - Cabrio (or X at BR 164)
	R = 5, // R - Roadster (or special protection B4 at BR 210 / 211/220 / V240)
	SS = 6, // SS - Special protection B6 / 7 (or CL at BR 203)
	SNV = 7, // Code not available
};

/** Vehicle code series */
enum class MS_608h_FCOD_BR {
	BR221 = 0, // BR 221 Od. BR 140
	BR129 = 1, // BR 129
	BR210 = 2, // BR 210 Od. BR 212
	BR202 = 3, // BR 202 Od. BR 204
	BR220 = 4, // BR 220
	BR170 = 5, // BR 170
	BR203 = 6, // BR 203
	BR168 = 7, // BR 168
	BR163 = 8, // BR 163
	BR208 = 9, // BR 208
	BR463 = 10, // BR 463
	BR215 = 11, // BR 215
	BR230 = 12, // BR 230
	BR211 = 13, // BR 211
	BR209 = 14, // BR 209
	BR461 = 15, // BR 461
	BR240 = 16, // BR 240
	BR251 = 17, // BR 251
	BR171 = 18, // BR 171
	BR164 = 19, // BR 164
	BR169 = 20, // BR 169 Od. BR 245
	BR199 = 21, // BR 199
	BR216 = 22, // BR 216
	BR219 = 23, // BR 219
	BR454 = 24, // BR 454 (Z-CAR)
	NCV2 = 25, // NCV2
	VITO = 26, // V-Class / Vito
	SPRINTER = 27, // Sprinter
	NCV3 = 28, // NCV3
	NCV1 = 29, // NCV1
	REST = 30, // All other BR
	SNV = 31, // Code not available
};

/** FZGCOD.Motor 7Bit, bit0-5 (bit6 -> signal fcod_mot6) */
enum class MS_608h_FCOD_MOT {
	M272E35 = 0, // M272 E35
	M271E18ML105 = 1, // M271 E18 ml Red. (105 kW)
	M271E18ML120 = 2, // M271 E18 ml (120 kW)
	M112E37 = 3, // M112 E37
	M272E25 = 4, // M272 E25
	M272E30 = 5, // M272 E30
	M112E28 = 7, // M112 E28
	M112E32 = 8, // M112 E32
	M273E46 = 10, // M273 E46
	M273E55 = 11, // M273 E55
	M112E26 = 12, // M112 E26
	M113E43 = 13, // M113 E43
	M113E50 = 14, // M113 E50
	M271E18ML140 = 18, // M271 E18 ML / 1 (140 kW)
	M271DE18ML105 = 19, // M271 DE18 ml Red. (105 kW)
	M271DE18ML125 = 20, // M271 DE18 ML (125 kW)
	M111E_E23ML = 22, // M111E E23 ML
	M111E_E20 = 23, // M111E E20
	M111E_E20ML = 24, // M111E E20 ml
	M112E32_140 = 25, // M112 E32 RED. (140 kW)
	M266E20ATL = 26, // M266 E20 ATL
	M266E15 = 27, // M266 E15
	M266E17 = 28, // M266 E17
	M266E20 = 29, // M266 E20
	M275E55 = 30, // M275 E55 Od. M285 E55
	M137E58 = 31, // M137 E58
	OM640DE20LA60 = 32, // OM 640 DE20 LA (60 kW)
	OM640DE20LA80 = 34, // OM 640 DE20 LA (80 kW)
	OM642DE30LA160 = 35, // OM642 DE30 LA (155/160 kW)
	OM640DE20LA100 = 36, // OM 640 DE20 LA (100 kW)
	OM613DE32LA = 37, // OM613 DE32 La od. OM648 DE32 LA
	OM628DE40LA = 39, // OM628 DE40 LA
	OM642DE30LA140 = 40, // OM642 DE30 LA (140 kW)
	OM612DE27LA = 43, // OM612 DE27 LA od. OM647 DE27 LA (120/130 kW)
	OM611DE22LA100 = 44, // OM611 DE22 LA (105/100 kW) Od. OM646 DE22 LA (100/105/110 kW)
	OM611DE22LA85 = 45, // OM611 DE22 LA (85 kW) Od. OM646 DE22 LA (90 kW)
	OM611DE22LA75 = 46, // OM611 DE22 LA (75 kW) Od. OM646 DE22 LA (75 kW)
	M134E11 = 64, // M134 E11 (3A91)
	M135E13 = 65, // M135 E13 (4A90)
	M135E15 = 66, // M135 E15 (4A91)
	M135E15ATL = 67, // M135 E15 ATL
	M272DE25 = 68, // M272 DE25
	M272DE30 = 69, // M272 DE30
	M272DE35 = 70, // M272 DE35
	M273DE46 = 71, // M273 DE46
	M273DE55 = 72, // M273 DE55
	M271E18MLATTR115 = 79, // M271 E18 ml Attr. (115kW)
	M271E18MLATTR141 = 80, // M271 E18 ml Attr. (141kW)
	OM629DE40LA = 96, // OM629 DE40 LA
	OM642DE30LARED140 = 99, // OM642 DE30 LA RED. (140kW)
};

/** Particle filter warning */
enum class MS_608h_PFW {
	OK = 0, // No warning
	PFW1 = 1, // Warning filters too, level 1
	PFW2 = 2, // Warning filters too, level 2
	SNV = 3, // signal not available
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_210 */
	uint32_t get_canid(){ return MS_210_CAN_ID; }
    /** Sets Air compressor Emergency Shutdown */
    void set_KOMP_NOTAUS(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Air compressor Emergency Shutdown */
    bool get_KOMP_NOTAUS() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets switching line shift MS */
    void set_SLV_MS(MS_210h_SLV_MS value){ raw = (raw & 0x87ffffffffffffff) | ((uint64_t)value & 0xf) << 59; }

    /** Gets switching line shift MS */
    MS_210h_SLV_MS get_SLV_MS() const { return (MS_210h_SLV_MS)(raw >> 59 & 0xf); }
        
    /** Sets Switch KSG-creep */
    void set_KRIECH_AUS(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Switch KSG-creep */
    bool get_KRIECH_AUS() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets MS-wish: "Approach 1.Gang" */
    void set_ANF1(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets MS-wish: "Approach 1.Gang" */
    bool get_ANF1() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets MS-wish: "Active downshift" */
    void set_AKT_R_MS(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets MS-wish: "Active downshift" */
    bool get_AKT_R_MS() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets Turn off heater */
    void set_ZH_AUS_MS(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets Turn off heater */
    bool get_ZH_AUS_MS() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets Gear, upper limit */
    void set_GMAX_MS(MS_210h_GMAX_MS value){ raw = (raw & 0xffc7ffffffffffff) | ((uint64_t)value & 0x7) << 51; }

    /** Gets Gear, upper limit */
    MS_210h_GMAX_MS get_GMAX_MS() const { return (MS_210h_GMAX_MS)(raw >> 51 & 0x7); }
        
    /** Sets Gear, lower limit */
    void set_GMIN_MS(MS_210h_GMIN_MS value){ raw = (raw & 0xfff8ffffffffffff) | ((uint64_t)value & 0x7) << 48; }

    /** Gets Gear, lower limit */
    MS_210h_GMIN_MS get_GMIN_MS() const { return (MS_210h_GMIN_MS)(raw >> 48 & 0x7); }
        
    /** Sets pedal. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_PW(uint8_t value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets pedal. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_PW() const { return (uint8_t)(raw >> 40 & 0xff); }
        
    /** Sets retrigger minimum display time in the display: S */
    void set_V_DSPL_NEU(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets retrigger minimum display time in the display: S */
    bool get_V_DSPL_NEU() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets idle is stable */
    void set_LL_STBL(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets idle is stable */
    bool get_LL_STBL() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets Vorglühstatus */
    void set_VGL_ST(bool value){ raw = (raw & 0xffffffdfffffffff) | ((uint64_t)value & 0x1) << 37; }

    /** Gets Vorglühstatus */
    bool get_VGL_ST() const { return (bool)(raw >> 37 & 0x1); }
        
    /** Sets Engine Start / Stop system is defective */
    void set_MSS_DEF(bool value){ raw = (raw & 0xffffffefffffffff) | ((uint64_t)value & 0x1) << 36; }

    /** Gets Engine Start / Stop system is defective */
    bool get_MSS_DEF() const { return (bool)(raw >> 36 & 0x1); }
        
    /** Sets engine start / stop system warning */
    void set_MSS_KL(bool value){ raw = (raw & 0xfffffff7ffffffff) | ((uint64_t)value & 0x1) << 35; }

    /** Gets engine start / stop system warning */
    bool get_MSS_KL() const { return (bool)(raw >> 35 & 0x1); }
        
    /** Sets engine start / stop system active */
    void set_MSS_AKT(bool value){ raw = (raw & 0xfffffffbffffffff) | ((uint64_t)value & 0x1) << 34; }

    /** Gets engine start / stop system active */
    bool get_MSS_AKT() const { return (bool)(raw >> 34 & 0x1); }
        
    /** Sets turn air compressor:: S acceleration */
    void set_KOMP_BAUS(bool value){ raw = (raw & 0xfffffffdffffffff) | ((uint64_t)value & 0x1) << 33; }

    /** Gets turn air compressor:: S acceleration */
    bool get_KOMP_BAUS() const { return (bool)(raw >> 33 & 0x1); }
        
    /** Sets Crash signal from motor control */
    void set_CRASH_MS(bool value){ raw = (raw & 0xfffffffeffffffff) | ((uint64_t)value & 0x1) << 32; }

    /** Gets Crash signal from motor control */
    bool get_CRASH_MS() const { return (bool)(raw >> 32 & 0x1); }
        
    /** Sets error pedal sensor */
    void set_PWG_ERR(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets error pedal sensor */
    bool get_PWG_ERR() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets idle */
    void set_LL(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets idle */
    bool get_LL() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets beg. "Slip" lock-up clutch */
    void set_KUEB_S_A(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets beg. "Slip" lock-up clutch */
    bool get_KUEB_S_A() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets cruise control regulates */
    void set_TM_REG(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets cruise control regulates */
    bool get_TM_REG() const { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets activated speed limit */
    void set_V_MAX_EIN(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets activated speed limit */
    bool get_V_MAX_EIN() const { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets Kick Down (changeover scenario open!) */
    void set_KD_MS(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets Kick Down (changeover scenario open!) */
    bool get_KD_MS() const { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets emergency operation */
    void set_NOTL(bool value){ raw = (raw & 0xfffffffffdffffff) | ((uint64_t)value & 0x1) << 25; }

    /** Gets emergency operation */
    bool get_NOTL() const { return (bool)(raw >> 25 & 0x1); }
        
    /** Sets Warning buzzer */
    void set_V_MAX_SUM(bool value){ raw = (raw & 0xfffffffffeffffff) | ((uint64_t)value & 0x1) << 24; }

    /** Gets Warning buzzer */
    bool get_V_MAX_SUM() const { return (bool)(raw >> 24 & 0x1); }
        
    /** Sets FBStart Error */
    void set_FBS_SE(bool value){ raw = (raw & 0xffffffffff7fffff) | ((uint64_t)value & 0x1) << 23; }

    /** Gets FBStart Error */
    bool get_FBS_SE() const { return (bool)(raw >> 23 & 0x1); }
        
    /** Sets "achieved winter tires limitation" Indicated on display */
    void set_V_DSPL_PGB(bool value){ raw = (raw & 0xffffffffffbfffff) | ((uint64_t)value & 0x1) << 22; }

    /** Gets "achieved winter tires limitation" Indicated on display */
    bool get_V_DSPL_PGB() const { return (bool)(raw >> 22 & 0x1); }
        
    /** Sets activated cruise control */
    void set_TM_EIN(bool value){ raw = (raw & 0xffffffffffdfffff) | ((uint64_t)value & 0x1) << 21; }

    /** Gets activated cruise control */
    bool get_TM_EIN() const { return (bool)(raw >> 21 & 0x1); }
        
    /** Sets Speed ​​controls */
    void set_V_MAX_REG(bool value){ raw = (raw & 0xffffffffffefffff) | ((uint64_t)value & 0x1) << 20; }

    /** Gets Speed ​​controls */
    bool get_V_MAX_REG() const { return (bool)(raw >> 20 & 0x1); }
        
    /** Sets Display "limit?" on display */
    void set_V_DSPL_LIM(bool value){ raw = (raw & 0xfffffffffff7ffff) | ((uint64_t)value & 0x1) << 19; }

    /** Gets Display "limit?" on display */
    bool get_V_DSPL_LIM() const { return (bool)(raw >> 19 & 0x1); }
        
    /** Sets "Error" indicator on the display */
    void set_V_DSPL_ERR(bool value){ raw = (raw & 0xfffffffffffbffff) | ((uint64_t)value & 0x1) << 18; }

    /** Gets "Error" indicator on the display */
    bool get_V_DSPL_ERR() const { return (bool)(raw >> 18 & 0x1); }
        
    /** Sets display flashes */
    void set_V_DSPL_BL(bool value){ raw = (raw & 0xfffffffffffdffff) | ((uint64_t)value & 0x1) << 17; }

    /** Gets display flashes */
    bool get_V_DSPL_BL() const { return (bool)(raw >> 17 & 0x1); }
        
    /** Sets Geschw.begrenzer- / cruise control display a */
    void set_V_DSPL_EIN(bool value){ raw = (raw & 0xfffffffffffeffff) | ((uint64_t)value & 0x1) << 16; }

    /** Gets Geschw.begrenzer- / cruise control display a */
    bool get_V_DSPL_EIN() const { return (bool)(raw >> 16 & 0x1); }
        
    /** Sets factor for fill value. d. max. Mom with remo.. A.druck. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_FMMOTMAX(uint8_t value){ raw = (raw & 0xffffffffffff00ff) | ((uint64_t)value & 0xff) << 8; }

    /** Gets factor for fill value. d. max. Mom with remo.. A.druck. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_FMMOTMAX() const { return (uint8_t)(raw >> 8 & 0xff); }
        
    /** Sets Set maximum or cruise control speed. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_V_MAX_TM(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets Set maximum or cruise control speed. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_V_MAX_TM() const { return (uint8_t)(raw >> 0 & 0xff); }
        
} MS_210;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_212 */
	uint32_t get_canid(){ return MS_212_CAN_ID; }
    /** Sets Motorley roll speed. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_NMOTS(uint16_t value){ raw = (raw & 0x0000ffffffffffff) | ((uint64_t)value & 0xffff) << 48; }

    /** Gets Motorley roll speed. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_NMOTS() const { return (uint16_t)(raw >> 48 & 0xffff); }
        
    /** Sets Serial mpomat is variant encoded */
    void set_TM_MS(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Serial mpomat is variant encoded */
    bool get_TM_MS() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Enable torque requirement type */
    void set_M_ART_E(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets Enable torque requirement type */
    bool get_M_ART_E() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets default torque driver. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_M_FV(uint16_t value){ raw = (raw & 0xffffe000ffffffff) | ((uint64_t)value & 0x1fff) << 32; }

    /** Gets default torque driver. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_M_FV() const { return (uint16_t)(raw >> 32 & 0x1fff); }
        
    /** Sets ENABLE Fast torque setting */
    void set_SME_E(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets ENABLE Fast torque setting */
    bool get_SME_E() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets Enable torque requirement ESP */
    void set_M_ESP_E(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets Enable torque requirement ESP */
    bool get_M_ESP_E() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets replacement feed torque driver. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_M_FEV(uint16_t value){ raw = (raw & 0xffffffffe000ffff) | ((uint64_t)value & 0x1fff) << 16; }

    /** Gets replacement feed torque driver. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_M_FEV() const { return (uint16_t)(raw >> 16 & 0x1fff); }
        
    /** Sets Transfer Calid / CVN Enable */
    void set_CALID_CVN_E(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets Transfer Calid / CVN Enable */
    bool get_CALID_CVN_E() const { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets acknowledgment torque requirement EGS */
    void set_M_EGS_Q(bool value){ raw = (raw & 0xffffffffffffbfff) | ((uint64_t)value & 0x1) << 14; }

    /** Gets acknowledgment torque requirement EGS */
    bool get_M_EGS_Q() const { return (bool)(raw >> 14 & 0x1); }
        
    /** Sets Enable torque requirement EGS */
    void set_M_EGS_E(bool value){ raw = (raw & 0xffffffffffffdfff) | ((uint64_t)value & 0x1) << 13; }

    /** Gets Enable torque requirement EGS */
    bool get_M_EGS_E() const { return (bool)(raw >> 13 & 0x1); }
        
    /** Sets default torque ESP. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_M_ESPV(uint16_t value){ raw = (raw & 0xffffffffffffe000) | ((uint64_t)value & 0x1fff) << 0; }

    /** Gets default torque ESP. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_M_ESPV() const { return (uint16_t)(raw >> 0 & 0x1fff); }
        
} MS_212;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_268 */
	uint32_t get_canid(){ return MS_268_CAN_ID; }
    /** Sets target translation, lower border (FCVT). Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_IMIN_MS(uint8_t value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets target translation, lower border (FCVT). Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_IMIN_MS() const { return (uint8_t)(raw >> 56 & 0xff); }
        
    /** Sets Target Translation, Upper Border (FCVT). Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_IMAX_MS(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Target Translation, Upper Border (FCVT). Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_IMAX_MS() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Terminal 61 */
    void set_KL_61_EIN(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Terminal 61 */
    bool get_KL_61_EIN() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Oil Info, reserved M266 */
    void set_OEL_INFO_169(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Oil Info, reserved M266 */
    bool get_OEL_INFO_169() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets shut-off valve cooling circuit M266 ATL */
    void set_ASV_KKL_169(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets shut-off valve cooling circuit M266 ATL */
    bool get_ASV_KKL_169() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets Status heating power */
    void set_HZL_ST(MS_268h_HZL_ST value){ raw = (raw & 0xfffffcffffffffff) | ((uint64_t)value & 0x3) << 40; }

    /** Gets Status heating power */
    MS_268h_HZL_ST get_HZL_ST() const { return (MS_268h_HZL_ST)(raw >> 40 & 0x3); }
        
    /** Sets Request for power-free in "D" (FCVT) */
    void set_KID_MS(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets Request for power-free in "D" (FCVT) */
    bool get_KID_MS() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets Mode air control system */
    void set_LRS_MODE(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets Mode air control system */
    bool get_LRS_MODE() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets Generator utilization (LIN generators only!). Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_LAST_GEN(uint8_t value){ raw = (raw & 0xffffffc0ffffffff) | ((uint64_t)value & 0x3f) << 32; }

    /** Gets Generator utilization (LIN generators only!). Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_LAST_GEN() const { return (uint8_t)(raw >> 32 & 0x3f); }
        
    /** Sets Max. Climate compressor torque. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_M_KOMP_MAX(uint8_t value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets Max. Climate compressor torque. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_M_KOMP_MAX() const { return (uint8_t)(raw >> 24 & 0xff); }
        
    /** Sets pedal value driver (only 169). Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_PW_F(uint8_t value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets pedal value driver (only 169). Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_PW_F() const { return (uint8_t)(raw >> 16 & 0xff); }
        
} MS_268;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_2F3 */
	uint32_t get_canid(){ return MS_2F3_CAN_ID; }
    /** Sets Drive Level Switching recommendation "is" */
    void set_FSC_IST(MS_2F3h_FSC_IST value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Drive Level Switching recommendation "is" */
    MS_2F3h_FSC_IST get_FSC_IST() const { return (MS_2F3h_FSC_IST)(raw >> 56 & 0xff); }
        
    /** Sets Drive Level Switching recommendation "should" */
    void set_FSC_SOLL(MS_2F3h_FSC_SOLL value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Drive Level Switching recommendation "should" */
    MS_2F3h_FSC_SOLL get_FSC_SOLL() const { return (MS_2F3h_FSC_SOLL)(raw >> 16 & 0xff); }
        
} MS_2F3;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_308 */
	uint32_t get_canid(){ return MS_308_CAN_ID; }
    /** Sets clutch kicked */
    void set_KPL(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets clutch kicked */
    bool get_KPL() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets start.Convertible bridging clutch "Open" */
    void set_KUEB_O_A(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets start.Convertible bridging clutch "Open" */
    bool get_KUEB_O_A() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Speed limiting function active */
    void set_N_MAX_BG(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Speed limiting function active */
    bool get_N_MAX_BG() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Partinal shutdown */
    void set_SAST(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Partinal shutdown */
    bool get_SAST() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets push shutdown full */
    void set_SASV(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets push shutdown full */
    bool get_SASV() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Fuel filter clogs control lamp (CR2 US only) */
    void set_KSF_KL(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Fuel filter clogs control lamp (CR2 US only) */
    bool get_KSF_KL() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Water in the fuel control lamp (CR2 US only) */
    void set_WKS_KL(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Water in the fuel control lamp (CR2 US only) */
    bool get_WKS_KL() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Cylinder shutdown conditions fulfilled */
    void set_ZASBED(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets Cylinder shutdown conditions fulfilled */
    bool get_ZASBED() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets engine speed. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_NMOT(uint16_t value){ raw = (raw & 0xff0000ffffffffff) | ((uint64_t)value & 0xffff) << 40; }

    /** Gets engine speed. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_NMOT() const { return (uint16_t)(raw >> 40 & 0xffff); }
        
    /** Sets Warning message ECO steering helping pump */
    void set_ELHP_WARN(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets Warning message ECO steering helping pump */
    bool get_ELHP_WARN() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets Ethanol operation detected */
    void set_EOH(bool value){ raw = (raw & 0xffffffdfffffffff) | ((uint64_t)value & 0x1) << 37; }

    /** Gets Ethanol operation detected */
    bool get_EOH() const { return (bool)(raw >> 37 & 0x1); }
        
    /** Sets Air filter dirty warning lamp (only diesel) */
    void set_LUFI_KL(bool value){ raw = (raw & 0xffffffefffffffff) | ((uint64_t)value & 0x1) << 36; }

    /** Gets Air filter dirty warning lamp (only diesel) */
    bool get_LUFI_KL() const { return (bool)(raw >> 36 & 0x1); }
        
    /** Sets pre-glow control lamp */
    void set_VGL_KL(bool value){ raw = (raw & 0xfffffff7ffffffff) | ((uint64_t)value & 0x1) << 35; }

    /** Gets pre-glow control lamp */
    bool get_VGL_KL() const { return (bool)(raw >> 35 & 0x1); }
        
    /** Sets oil level / oil pressure control lamp */
    void set_OEL_KL(bool value){ raw = (raw & 0xfffffffbffffffff) | ((uint64_t)value & 0x1) << 34; }

    /** Gets oil level / oil pressure control lamp */
    bool get_OEL_KL() const { return (bool)(raw >> 34 & 0x1); }
        
    /** Sets Diagnosis Control Lamp (OBD II) */
    void set_DIAG_KL(bool value){ raw = (raw & 0xfffffffdffffffff) | ((uint64_t)value & 0x1) << 33; }

    /** Gets Diagnosis Control Lamp (OBD II) */
    bool get_DIAG_KL() const { return (bool)(raw >> 33 & 0x1); }
        
    /** Sets Tank lid open check lamp */
    void set_TANK_KL(bool value){ raw = (raw & 0xfffffffeffffffff) | ((uint64_t)value & 0x1) << 32; }

    /** Gets Tank lid open check lamp */
    bool get_TANK_KL() const { return (bool)(raw >> 32 & 0x1); }
        
    /** Sets Engine oil temperature too high (overheating) */
    void set_UEHITZ(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets Engine oil temperature too high (overheating) */
    bool get_UEHITZ() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets Cylinder shutdown */
    void set_ZAS(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets Cylinder shutdown */
    bool get_ZAS() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets ADR check lamp (NFZ only) */
    void set_ADR_KL(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets ADR check lamp (NFZ only) */
    bool get_ADR_KL() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets ADR defective control lamp (NFZ only) */
    void set_ADR_DEF_KL(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets ADR defective control lamp (NFZ only) */
    bool get_ADR_DEF_KL() const { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets starter is running */
    void set_ANL_LFT(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets starter is running */
    bool get_ANL_LFT() const { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets Motor Heater Defective Control Lamp */
    void set_LUEFT_MOT_KL(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets Motor Heater Defective Control Lamp */
    bool get_LUEFT_MOT_KL() const { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets Speed limitation for display active (0 at CR) */
    void set_DBAA(bool value){ raw = (raw & 0xfffffffffdffffff) | ((uint64_t)value & 0x1) << 25; }

    /** Gets Speed limitation for display active (0 at CR) */
    bool get_DBAA() const { return (bool)(raw >> 25 & 0x1); }
        
    /** Sets cooling water temperature too high */
    void set_TEMP_KL(bool value){ raw = (raw & 0xfffffffffeffffff) | ((uint64_t)value & 0x1) << 24; }

    /** Gets cooling water temperature too high */
    bool get_TEMP_KL() const { return (bool)(raw >> 24 & 0x1); }
        
    /** Sets Oil temperature. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_T_OEL(uint8_t value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Oil temperature. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_T_OEL() const { return (uint8_t)(raw >> 16 & 0xff); }
        
    /** Sets oil level. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_OEL_FS(uint8_t value){ raw = (raw & 0xffffffffffff00ff) | ((uint64_t)value & 0xff) << 8; }

    /** Gets oil level. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_OEL_FS() const { return (uint8_t)(raw >> 8 & 0xff); }
        
    /** Sets oil quality. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_OEL_QUAL(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets oil quality. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_OEL_QUAL() const { return (uint8_t)(raw >> 0 & 0xff); }
        
} MS_308;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_312 */
	uint32_t get_canid(){ return MS_312_CAN_ID; }
    /** Sets Motor torque static. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_M_STA(uint16_t value){ raw = (raw & 0xe000ffffffffffff) | ((uint64_t)value & 0x1fff) << 48; }

    /** Gets Motor torque static. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_M_STA() const { return (uint16_t)(raw >> 48 & 0x1fff); }
        
    /** Sets Motor Torque Maximum incl. DYN.Turbocharger. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_M_MAX_ATL(uint16_t value){ raw = (raw & 0xffffe000ffffffff) | ((uint64_t)value & 0x1fff) << 32; }

    /** Gets Motor Torque Maximum incl. DYN.Turbocharger. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_M_MAX_ATL() const { return (uint16_t)(raw >> 32 & 0x1fff); }
        
    /** Sets Motor torque maximum. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_M_MAX(uint16_t value){ raw = (raw & 0xffffffffe000ffff) | ((uint64_t)value & 0x1fff) << 16; }

    /** Gets Motor torque maximum. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_M_MAX() const { return (uint16_t)(raw >> 16 & 0x1fff); }
        
    /** Sets Motor torque minimal. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_M_MIN(uint16_t value){ raw = (raw & 0xffffffffffffe000) | ((uint64_t)value & 0x1fff) << 0; }

    /** Gets Motor torque minimal. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_M_MIN() const { return (uint16_t)(raw >> 0 & 0x1fff); }
        
} MS_312;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of AAD_580 */
	uint32_t get_canid(){ return AAD_580_CAN_ID; }
    /** Sets indicator acceleration type (> 100: dynamic). Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_FTK_BMI(uint8_t value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets indicator acceleration type (> 100: dynamic). Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_FTK_BMI() const { return (uint8_t)(raw >> 56 & 0xff); }
        
    /** Sets Code of the transverse acceleration type (> 100: dynamic). Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_FTK_LMI(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Code of the transverse acceleration type (> 100: dynamic). Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_FTK_LMI() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets code number brake type (> 100: dynamic). Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_FTK_VMI(uint8_t value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets code number brake type (> 100: dynamic). Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_FTK_VMI() const { return (uint8_t)(raw >> 40 & 0xff); }
        
    /** Sets Max. Diff.Pedal angle value per maneuver. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_FTK_DPW(uint8_t value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets Max. Diff.Pedal angle value per maneuver. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_FTK_DPW() const { return (uint8_t)(raw >> 24 & 0xff); }
        
    /** Sets Continuous driver watching. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_AADKB(uint8_t value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Continuous driver watching. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_AADKB() const { return (uint8_t)(raw >> 16 & 0xff); }
        
    /** Sets Spontaneous dynamic requirement */
    void set_AADKBDYN(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets Spontaneous dynamic requirement */
    bool get_AADKBDYN() const { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets nervousness. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_AADNT(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets nervousness. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_AADNT() const { return (uint8_t)(raw >> 0 & 0xff); }
        
} AAD_580;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_608 */
	uint32_t get_canid(){ return MS_608_CAN_ID; }
    /** Sets engine coolant temperature. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_T_MOT(uint8_t value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets engine coolant temperature. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_T_MOT() const { return (uint8_t)(raw >> 56 & 0xff); }
        
    /** Sets intake air temperature. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_T_LUFT(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets intake air temperature. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_T_LUFT() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Vehicle code body */
    void set_FCOD_KAR(MS_608h_FCOD_KAR value){ raw = (raw & 0xffff1fffffffffff) | ((uint64_t)value & 0x7) << 45; }

    /** Gets Vehicle code body */
    MS_608h_FCOD_KAR get_FCOD_KAR() const { return (MS_608h_FCOD_KAR)(raw >> 45 & 0x7); }
        
    /** Sets Vehicle code series */
    void set_FCOD_BR(MS_608h_FCOD_BR value){ raw = (raw & 0xffffe0ffffffffff) | ((uint64_t)value & 0x1f) << 40; }

    /** Gets Vehicle code series */
    MS_608h_FCOD_BR get_FCOD_BR() const { return (MS_608h_FCOD_BR)(raw >> 40 & 0x1f); }
        
    /** Sets Vehicle code engine with 7 bit, bit 6 */
    void set_FCOD_MOT6(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets Vehicle code engine with 7 bit, bit 6 */
    bool get_FCOD_MOT6() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets Transmission control not available */
    void set_GS_NVH(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets Transmission control not available */
    bool get_GS_NVH() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets FZGCOD.Motor 7Bit, bit0-5 (bit6 -> signal fcod_mot6) */
    void set_FCOD_MOT(MS_608h_FCOD_MOT value){ raw = (raw & 0xffffffc0ffffffff) | ((uint64_t)value & 0x3f) << 32; }

    /** Gets FZGCOD.Motor 7Bit, bit0-5 (bit6 -> signal fcod_mot6) */
    MS_608h_FCOD_MOT get_FCOD_MOT() const { return (MS_608h_FCOD_MOT)(raw >> 32 & 0x3f); }
        
    /** Sets Fixed maximum speed. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_V_MAX_FIX(uint8_t value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets Fixed maximum speed. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_V_MAX_FIX() const { return (uint8_t)(raw >> 24 & 0xff); }
        
    /** Sets consumption. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_VB(uint16_t value){ raw = (raw & 0xffffffffff0000ff) | ((uint64_t)value & 0xffff) << 8; }

    /** Gets consumption. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_VB() const { return (uint16_t)(raw >> 8 & 0xffff); }
        
    /** Sets Turn on auxiliary water pump */
    void set_ZWP_EIN_MS(bool value){ raw = (raw & 0xffffffffffffff7f) | ((uint64_t)value & 0x1) << 7; }

    /** Gets Turn on auxiliary water pump */
    bool get_ZWP_EIN_MS() const { return (bool)(raw >> 7 & 0x1); }
        
    /** Sets Particle filter warning */
    void set_PFW(MS_608h_PFW value){ raw = (raw & 0xffffffffffffff9f) | ((uint64_t)value & 0x3) << 5; }

    /** Gets Particle filter warning */
    MS_608h_PFW get_PFW() const { return (MS_608h_PFW)(raw >> 5 & 0x3); }
        
    /** Sets Switch on additional consumers */
    void set_ZVB_EIN_MS(bool value){ raw = (raw & 0xffffffffffffffef) | ((uint64_t)value & 0x1) << 4; }

    /** Gets Switch on additional consumers */
    bool get_ZVB_EIN_MS() const { return (bool)(raw >> 4 & 0x1); }
        
    /** Sets Particle Filter Correction Offset FMMOTMAX. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_PFKO(uint8_t value){ raw = (raw & 0xfffffffffffffff0) | ((uint64_t)value & 0xf) << 0; }

    /** Gets Particle Filter Correction Offset FMMOTMAX. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_PFKO() const { return (uint8_t)(raw >> 0 & 0xf); }
        
} MS_608;



class ECU_MS {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case MS_210_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case MS_212_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                case MS_268_CAN_ID:
                    LAST_FRAME_TIMES[2] = timestamp_now;
                    FRAME_DATA[2] = value;
                    return true;
                case MS_2F3_CAN_ID:
                    LAST_FRAME_TIMES[3] = timestamp_now;
                    FRAME_DATA[3] = value;
                    return true;
                case MS_308_CAN_ID:
                    LAST_FRAME_TIMES[4] = timestamp_now;
                    FRAME_DATA[4] = value;
                    return true;
                case MS_312_CAN_ID:
                    LAST_FRAME_TIMES[5] = timestamp_now;
                    FRAME_DATA[5] = value;
                    return true;
                case AAD_580_CAN_ID:
                    LAST_FRAME_TIMES[6] = timestamp_now;
                    FRAME_DATA[6] = value;
                    return true;
                case MS_608_CAN_ID:
                    LAST_FRAME_TIMES[7] = timestamp_now;
                    FRAME_DATA[7] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to MS_210
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_210(uint64_t now, uint64_t max_expire_time, MS_210* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[0] && now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_212
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_212(uint64_t now, uint64_t max_expire_time, MS_212* dest) const {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[1] && now - LAST_FRAME_TIMES[1] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[1];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_268
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_268(uint64_t now, uint64_t max_expire_time, MS_268* dest) const {
            if (LAST_FRAME_TIMES[2] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[2] && now - LAST_FRAME_TIMES[2] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[2];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_2F3
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_2F3(uint64_t now, uint64_t max_expire_time, MS_2F3* dest) const {
            if (LAST_FRAME_TIMES[3] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[3] && now - LAST_FRAME_TIMES[3] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[3];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_308
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_308(uint64_t now, uint64_t max_expire_time, MS_308* dest) const {
            if (LAST_FRAME_TIMES[4] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[4] && now - LAST_FRAME_TIMES[4] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[4];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_312
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_312(uint64_t now, uint64_t max_expire_time, MS_312* dest) const {
            if (LAST_FRAME_TIMES[5] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[5] && now - LAST_FRAME_TIMES[5] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[5];
                return true;
            }
        }
            
        /** Sets data in pointer to AAD_580
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_AAD_580(uint64_t now, uint64_t max_expire_time, AAD_580* dest) const {
            if (LAST_FRAME_TIMES[6] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[6] && now - LAST_FRAME_TIMES[6] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[6];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_608
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_608(uint64_t now, uint64_t max_expire_time, MS_608* dest) const {
            if (LAST_FRAME_TIMES[7] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[7] && now - LAST_FRAME_TIMES[7] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[7];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[8];
		uint64_t LAST_FRAME_TIMES[8];
};
#endif // __ECU_MS_H_