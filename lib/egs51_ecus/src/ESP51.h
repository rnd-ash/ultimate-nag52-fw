
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'ESP51'
*/

#ifndef __ECU_ESP51_H_
#define __ECU_ESP51_H_

#include <stdint.h>
    
#define BS_200_EGS51_CAN_ID 0x0200
#define BS_208_EGS51_CAN_ID 0x0208

/** brake light switch */
enum class BS_200h_BLS_EGS51 : uint16_t {
	BREMSE_NBET = 0, // Brake not actuated
	BREMSE_BET = 1, // brake actuated
	UNKNOWN = 2, // not defined
	SNV = 3, // signal not available
};

/** rotary direction wheel front left */
enum class BS_200h_DRTGVL_EGS51 : uint16_t {
	PASSIVE = 0, // No rotation detection
	FWD = 1, // direction of rotation forward
	REV = 2, // direction of rotation backwards
	SNV = 3, // signal not available
};

/** direction of rotation wheel front right */
enum class BS_200h_DRTGVR_EGS51 : uint16_t {
	PASSIVE = 0, // No rotation detection
	FWD = 1, // direction of rotation forward
	REV = 2, // direction of rotation backwards
	SNV = 3, // signal not available
};

/** Rad Left for Cruise */
enum class BS_200h_DRTGTM_EGS51 : uint16_t {
	PASSIVE = 0, // No rotation detection
	FWD = 1, // direction of rotation forward
	REV = 2, // direction of rotation backwards
	SNV = 3, // signal not available
};

/** Gear, upper limit */
enum class BS_208h_GMAX_ESP_EGS51 : uint16_t {
	PASSIVE = 0, // passive value
	G1 = 1, // Gear, upper limit = 1
	G2 = 2, // Gear, upper limit = 2
	G3 = 3, // Gear, upper limit = 3
	G4 = 4, // Gear, upper limit = 4
	G5 = 5, // Gear, upper limit = 5
	G6 = 6, // Gear, upper limit = 6
	G7 = 7, // Gear, upper limit = 7
};

/** Gear, lower limit */
enum class BS_208h_GMIN_ESP_EGS51 : uint16_t {
	PASSIVE = 0, // passive value
	G1 = 1, // Gear, lower limit = 1
	G2 = 2, // Gear, lower limit = 2
	G3 = 3, // Gear, lower limit = 3
	G4 = 4, // Gear, lower limit = 4
	G5 = 5, // Gear, lower limit = 5
	G6 = 6, // Gear, lower limit = 6
	G7 = 7, // Gear, lower limit = 7
};

/** system condition */
enum class BS_208h_SZS_EGS51 : uint16_t {
	ERR = 0, // system error
	NORM = 1, // normal operation
	DIAG = 2, // Diagnosis
	ABGAS = 3, // exhaust gas test
};

/** Switching Difference ESP */
enum class BS_208h_SLV_ESP_EGS51 : uint16_t {
	SKL0 = 0, // Shift characteristic "0"
	SKL1 = 1, // Shift characteristic "1"
	SKL2 = 2, // Shift characteristic "2"
	SKL3 = 3, // Shift characteristic "3"
	SKL4 = 4, // Shift characteristic "4"
	SKL5 = 5, // Shift characteristic "5"
	SKL6 = 6, // Shift characteristic "6"
	SKL7 = 7, // Shift characteristic "7"
	SKL8 = 8, // Shift characteristic "8"
	SKL9 = 9, // Shift characteristic "9"
	SKL10 = 10, // Shift characteristic "10"
};

/** ESP request: "N" Insert */
enum class BS_208h_ANFN_EGS51 : uint16_t {
	UNKNOWN = 0, // not defined
	ANF_N = 1, // requirement "neutral"
	IDLE = 2, // No requirement
	SNV = 3, // signal not available
};

/** rotary direction wheel rear right */
enum class BS_208h_DRTGHR_EGS51 : uint16_t {
	PASSIVE = 0, // No rotation detection
	FWD = 1, // direction of rotation forward
	REV = 2, // direction of rotation backwards
	SNV = 3, // signal not available
};

/** rotary direction wheel rear left */
enum class BS_208h_DRTGHL_EGS51 : uint16_t {
	PASSIVE = 0, // No rotation detection
	FWD = 1, // direction of rotation forward
	REV = 2, // direction of rotation backwards
	SNV = 3, // signal not available
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** wheel speed links for cruise control **/
		uint16_t TM_DL: 14;
		/** Rad Left for Cruise **/
		BS_200h_DRTGTM_EGS51 DRTGTM: 2;
		/** Right speed front right **/
		uint16_t DVR: 14;
		/** direction of rotation wheel front right **/
		BS_200h_DRTGVR_EGS51 DRTGVR: 2;
		/** wheel speed front left **/
		uint16_t DVL: 14;
		/** rotary direction wheel front left **/
		BS_200h_DRTGVL_EGS51 DRTGVL: 2;
		/** brake light switch **/
		BS_200h_BLS_EGS51 BLS: 2;
		/** Message counter **/
		uint8_t BZ200h: 4;
		/** BLS Parity (straight parity) **/
		bool BLS_PA: 1;
		/** Brake light suppression (EBV_KL at 163 / T0 / T1N) **/
		bool BLS_UNT: 1;
		/** brake pad wear control lamp **/
		bool BBV_KL: 1;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		bool __PADDING1__: 1;
		/** ABS defective control lamp **/
		bool ABS_KL: 1;
		/** ESP defective control lamp **/
		bool ESP_KL: 1;
		/** ESP Info lamp permanent light **/
		bool ESP_INFO_DL: 1;
		/** ESP Infolramp flashing light **/
		bool ESP_INFO_BL: 1;
		/** Bas defective control lamp **/
		bool BAS_KL: 1;
		/** Brake defective control lamp (EBV_KL at 463/461 / NCV2) **/
		bool BRE_KL: 1;
	} __attribute__((packed));
	/** Gets CAN ID of BS_200_EGS51 **/
	uint32_t get_canid(){ return BS_200_EGS51_CAN_ID; }
} BS_200_EGS51;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** Rear wheel speed **/
		uint16_t DHL: 14;
		/** rotary direction wheel rear left **/
		BS_208h_DRTGHL_EGS51 DRTGHL: 2;
		/** Rear wheel speed **/
		uint16_t DHR: 14;
		/** rotary direction wheel rear right **/
		BS_208h_DRTGHR_EGS51 DRTGHR: 2;
		/** set braking torque (BR240 factor 1.8 larger) **/
		uint16_t MBRE_ESP: 12;
		/** ART brake intervention active **/
		bool BRE_AKT_ART: 1;
		/** ESP request: "N" Insert **/
		BS_208h_ANFN_EGS51 ANFN: 2;
		/** ESP brake engagement active **/
		bool BRE_AKT_ESP: 1;
		/** Switching Difference ESP **/
		BS_208h_SLV_ESP_EGS51 SLV_ESP: 4;
		/** Tempomat operation **/
		bool TM_AUS: 1;
		/** system condition **/
		BS_208h_SZS_EGS51 SZS: 2;
		/** Suppression Dynamic fully detection **/
		bool DDYN_UNT: 1;
		/** Gear, lower limit **/
		BS_208h_GMIN_ESP_EGS51 GMIN_ESP: 3;
		/** Gear, upper limit **/
		BS_208h_GMAX_ESP_EGS51 GMAX_ESP: 3;
		/** Gear requirement of art **/
		bool MINMAX_ART: 1;
		/** ESP / Art-Wish: "Active Retract" **/
		bool AKT_R_ESP: 1;
	} __attribute__((packed));
	/** Gets CAN ID of BS_208_EGS51 **/
	uint32_t get_canid(){ return BS_208_EGS51_CAN_ID; }
} BS_208_EGS51;



class ECU_ESP51 {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            uint8_t idx = 0;
            bool add = true;
            switch(can_id) {
                case BS_200_EGS51_CAN_ID:
                    idx = 0;
                    break;
                case BS_208_EGS51_CAN_ID:
                    idx = 1;
                    break;
                default:
                    add = false;
                    break;
            }
            if (add) {
                LAST_FRAME_TIMES[idx] = timestamp_now;
                FRAME_DATA[idx] = value;
            }
            return add;
        }
        
        /** Sets data in pointer to BS_200
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_200(uint64_t now, uint64_t max_expire_time, BS_200_EGS51* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[0] <= now && now - LAST_FRAME_TIMES[0] < max_expire_time) {
                dest->raw = FRAME_DATA[0];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to BS_208
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_208(uint64_t now, uint64_t max_expire_time, BS_208_EGS51* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[1] <= now && now - LAST_FRAME_TIMES[1] < max_expire_time) {
                dest->raw = FRAME_DATA[1];
                ret = true;
            }
            return ret;
        }
            
	private:
		uint64_t FRAME_DATA[2];
		uint64_t LAST_FRAME_TIMES[2];
};
#endif // __ECU_ESP51_H_