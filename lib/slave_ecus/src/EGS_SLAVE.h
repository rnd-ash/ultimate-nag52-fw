
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'EGS_SLAVE'
*/

#ifndef ECU_EGS_SLAVE_H
#define ECU_EGS_SLAVE_H

#include <stdint.h>
    
#define SOLENOID_REPORT_EGS_SLAVE_CAN_ID 0x050A
#define SENSOR_REPORT_EGS_SLAVE_CAN_ID 0x050B
#define UN52_REPORT_EGS_SLAVE_CAN_ID 0x050C



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint16_t __PADDING1__: 16;
		/** Recorded TCC PWM **/
		uint8_t TCC_PWM: 8;
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING2__: 8;
		/** Recorded SPC Current **/
		uint16_t SPC_CURR: 16;
		/** Recorded MPC Current **/
		uint16_t MPC_CURR: 16;
	} __attribute__((packed));
	/** Gets CAN ID of SOLENOID_REPORT_EGS_SLAVE **/
	uint32_t get_canid(){ return SOLENOID_REPORT_EGS_SLAVE_CAN_ID; }
} SOLENOID_REPORT_EGS_SLAVE;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		 /** BITFIELD PADDING. DO NOT CHANGE **/
		uint8_t __PADDING1__: 8;
		/** Recorded ATF Temperature (0xFF if Parking is engaged) **/
		uint8_t TFT: 8;
		/** Recorded battery voltage **/
		uint8_t VBATT: 8;
		/** Recorded Output pulse count **/
		uint16_t OUT_RAW: 16;
		/** Recorded N3 pulse count **/
		uint16_t N3_RAW: 16;
		/** Recorded N2 pulse count **/
		uint16_t N2_RAW: 16;
	} __attribute__((packed));
	/** Gets CAN ID of SENSOR_REPORT_EGS_SLAVE **/
	uint32_t get_canid(){ return SENSOR_REPORT_EGS_SLAVE_CAN_ID; }
} SENSOR_REPORT_EGS_SLAVE;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		/** Recorded TCC Current **/
		uint16_t TCC_CURR: 16;
		/** Recorded Y5 Current **/
		uint16_t Y5_CURR: 16;
		/** Recorded Y4 Current **/
		uint16_t Y4_CURR: 16;
		/** Recorded Y3 Current **/
		uint16_t Y3_CURR: 16;
	} __attribute__((packed));
	/** Gets CAN ID of UN52_REPORT_EGS_SLAVE **/
	uint32_t get_canid(){ return UN52_REPORT_EGS_SLAVE_CAN_ID; }
} UN52_REPORT_EGS_SLAVE;



class ECU_EGS_SLAVE {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint32_t timestamp_now) {
            uint8_t idx = 0;
            bool add = true;
            switch(can_id) {
                case SOLENOID_REPORT_EGS_SLAVE_CAN_ID:
                    idx = 0;
                    break;
                case SENSOR_REPORT_EGS_SLAVE_CAN_ID:
                    idx = 1;
                    break;
                case UN52_REPORT_EGS_SLAVE_CAN_ID:
                    idx = 2;
                    break;
                default:
                    add = false;
                    break;
            }
            if (add) {
                LAST_FRAME_TIMES[idx] = timestamp_now;
                FRAME_DATA[idx] = value;
            }
            return add;
        }
        
        /** Sets data in pointer to SOLENOID_REPORT
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SOLENOID_REPORT(const uint32_t now, const uint32_t max_expire_time, SOLENOID_REPORT_EGS_SLAVE* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[0] <= now && now - LAST_FRAME_TIMES[0] < max_expire_time) {
                dest->raw = FRAME_DATA[0];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to SENSOR_REPORT
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SENSOR_REPORT(const uint32_t now, const uint32_t max_expire_time, SENSOR_REPORT_EGS_SLAVE* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[1] <= now && now - LAST_FRAME_TIMES[1] < max_expire_time) {
                dest->raw = FRAME_DATA[1];
                ret = true;
            }
            return ret;
        }
            
        /** Sets data in pointer to UN52_REPORT
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_UN52_REPORT(const uint32_t now, const uint32_t max_expire_time, UN52_REPORT_EGS_SLAVE* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[2] <= now && now - LAST_FRAME_TIMES[2] < max_expire_time) {
                dest->raw = FRAME_DATA[2];
                ret = true;
            }
            return ret;
        }
            
	private:
		uint64_t FRAME_DATA[3];
		uint32_t LAST_FRAME_TIMES[3];
};
#endif // ECU_EGS_SLAVE_H